"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[7459],{5680:(e,n,t)=>{t.d(n,{xA:()=>u,yg:()=>h});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),p=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(l.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(t),g=a,h=c["".concat(l,".").concat(g)]||c[g]||d[g]||o;return t?r.createElement(h,i(i({ref:n},u),{},{components:t})):r.createElement(h,i({ref:n},u))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=g;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},1880:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=t(8168),a=(t(6540),t(5680));const o={sidebar_position:9},i="A character study",s={unversionedId:"tutorial/a-character-study",id:"tutorial/a-character-study",title:"A character study",description:"String Token",source:"@site/docs/tutorial/a-character-study.mdx",sourceDirName:"tutorial",slug:"/tutorial/a-character-study",permalink:"/docs/tutorial/a-character-study",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial/a-character-study.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"To be or not to be?",permalink:"/docs/tutorial/to-be-or-not-to-be"},next:{title:"More to come...",permalink:"/docs/tutorial/more-to-come"}},l={},p=[{value:"String Token",id:"string-token",level:3},{value:"Regular Expression",id:"regular-expression",level:3},{value:"Match Method",id:"match-method",level:3}],u={toc:p},c="wrapper";function d(e){let{components:n,...t}=e;return(0,a.yg)(c,(0,r.A)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"a-character-study"},"A character study"),(0,a.yg)("h3",{id:"string-token"},"String Token"),(0,a.yg)("p",null,"Up until now we've been dealing solely with numbers and indirectly booleans, but let's see how easy it is to add\nString support to use with our statements. ",(0,a.yg)("strong",{parentName:"p"},"NOTE"),": The following implementation goes over and above what a String\nneeds to achieve, however I feel it's important to bring up these features should you use them elsewhere in your tokens.\nWith that being said, let's get started."),(0,a.yg)("p",null,"In our case we'll add String support for both single and double-quote characters. This will require a slightly different\napproach in our token which I'll explain below. Firstly, let's add a new StringToken.java class to our ",(0,a.yg)("inlineCode",{parentName:"p"},"tokens.literals"),"\npackage. We'll then define the following:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'public class StringToken extends Token<String> {\n\n    public StringToken() { super("String", null); }\n\n    public StringToken(String value) {\n        super("String", value);\n    }\n\n    @Override\n    public PatternType getPatternType() {\n        return PatternType.REGEX;\n    }\n\n    @Override\n    public String getPattern() {\n        return "^(\\"(.*?[^\\\\\\\\])\\"|\'(.*?[^\\\\\\\\])\')";\n    }\n\n    @Override\n    public Optional<String> getGuidance(String token, List<Integer> groupsCount) {\n        return Optional.empty();\n    }\n\n    @Override\n    public Optional<Token<String>> match(Expression expression, boolean dryRun) {\n        Matcher m = getMatcher(expression.getValue());\n        if (m.find()) {\n            if (!dryRun) expression.cutTo(m.end(0));\n            String value = Objects.isNull(m.group(2)) ? m.group(3) : m.group(2);\n            value = value.replace("\\\\\\"", "\\"");\n            value = value.replace("\\\\\'", "\'");\n            return Optional.of(createToken(value));\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n        return Collections.singletonList(this);\n    }\n\n    @Override\n    public Token<String> createToken(String value) {\n        return new StringToken(value);\n    }\n\n    @Override\n    public String toString() {\n        return String.format("\'%s\'", getValue());\n    }\n}\n')),(0,a.yg)("p",null,"There are a couple of differences here which I'll explain:"),(0,a.yg)("h3",{id:"regular-expression"},"Regular Expression"),(0,a.yg)("p",null,"Considering a String is just some text surrounding with a character (",(0,a.yg)("inlineCode",{parentName:"p"},"'")," or ",(0,a.yg)("inlineCode",{parentName:"p"},'"'),"), why is the definition so\ncomplicated? Ignoring the Java escape backslashes, the actual expression is ",(0,a.yg)("inlineCode",{parentName:"p"},"^(\\\"(.*?[^\\\\])\\\"|'(.*?[^\\\\])')"),". Looking\nat it, we can see that it starts with the typical ",(0,a.yg)("inlineCode",{parentName:"p"},"^")," which means the beginning of a String. We then have a set of\nbrackets which represent a capture group."),(0,a.yg)("p",null,"Half way through the capture group you'll see a ",(0,a.yg)("inlineCode",{parentName:"p"},"|")," which acts as a logical or, meaning it can match the pattern\nfound before or after. Since both sides are the same besides the character used, we'll look at the first of these\n",(0,a.yg)("inlineCode",{parentName:"p"},'"(.*?[^\\\\])"'),". We start with a ",(0,a.yg)("inlineCode",{parentName:"p"},'"')," in this case and have another set of brackets for a group to capture the text\ncontent found within. ",(0,a.yg)("inlineCode",{parentName:"p"},".*")," means match any character (",(0,a.yg)("inlineCode",{parentName:"p"},"."),") 0 or more times (",(0,a.yg)("inlineCode",{parentName:"p"},"*"),"). The next ",(0,a.yg)("inlineCode",{parentName:"p"},"?")," means match as\nfew characters as possible. We then have a group of characters which, as they start with a ",(0,a.yg)("inlineCode",{parentName:"p"},"^")," character mean they\nare to be ignored. Why would we do this? Well, say we want to embed a String within a String, the only way for this\nto happen would be to use an escape character. In this case we're using the backslash to represent that."),(0,a.yg)("p",null,"As such, we should be able to support both single and double-quoted Strings, but also those which contain escaped\nString quotations within the Strings themselves! Because we're using that logical or though, we do need to modify\nthe way in which we map the capture groups. As such, this brings us onto the next change."),(0,a.yg)("h3",{id:"match-method"},"Match Method"),(0,a.yg)("p",null,"This method gets called when the lexer is trying to find a match for the next token. Typically it would use the single\ncapture group defined (index 1). In our case though, we've defined not just one, but embedded groups two and three\nrepresenting both sides of the or for ",(0,a.yg)("inlineCode",{parentName:"p"},'"')," and ",(0,a.yg)("inlineCode",{parentName:"p"},"'")," respectively. As such, we need to find which group returns a\nmatch and use that as our value."),(0,a.yg)("p",null,"The majority of this code matches the method from which it overrides. The first line creates a regular expression\nmatcher object from the pattern and returns it. We then determine if a match has been found and if so checks a\ndry-run boolean flag. This flag is used when we want to check for a match, but not affect the expression itself. If\nit is not a dry-run it removes the matched portion of text from the beginning of the expression. We then check capture\ngroup 2 (",(0,a.yg)("inlineCode",{parentName:"p"},'"'),") for a match and if none is found then we'll defer to group 3 (",(0,a.yg)("inlineCode",{parentName:"p"},"'"),"). I've extracted the block of\ncode we're using to select the group, modify it and pass it to become a new instance of the StringToken to be returned\nto the lexer:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'String value = Objects.isNull(m.group(2)) ? m.group(3) : m.group(2);\nvalue = value.replace("\\\\\\"", "\\"");\nvalue = value.replace("\\\\\'", "\'");\nreturn Optional.of(createToken(value));\n')),(0,a.yg)("p",null,"Unfortunately I am not aware of a method to remove characters for this scenario via regex. As such, we use a standard\n",(0,a.yg)("inlineCode",{parentName:"p"},"String.replace")," to remove the backslashes from our matched String. If you didn't manage to follow what I wrote above,\nit's not strictly necessary to understand all of this, but if you're interested I would suggest adding a breakpoint to\nthe method to get a better idea of how it works."),(0,a.yg)("p",null,"Ok, time to test it by adding it to our configuration and giving it a try in the expression runner:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class AardvarkConfig extends LARFConfig {\n    //...\n    @Override\n    protected void initTokenHandlers() {\n        //Literals\n        addTokenHandler(new NullToken());\n        addTokenHandler(new IntegerToken());\n        addTokenHandler(new DecimalToken());\n        addTokenHandler(new BooleanToken());  \n        addTokenHandler(new StringToken());\n\n        //Statements\n        addTokenHandler(new ExpressionToken());\n        addTokenHandler(new ConditionalToken());\n    }\n    //...\n}\n")),(0,a.yg)("p",null,"Runner:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'\'hello\'\nResult: hello (Type: String, Time taken: 11ms)\n"hello world!"\nResult: hello world! (Type: String, Time taken: 1ms)\n"The alien shouted \\"zee oot!\\", then flew off"\nResult: The alien shouted "zee oot!", then flew off (Type: String, Time taken: 1ms)\n')),(0,a.yg)("p",null,"So far so good, but let's take things further by adding String operator support. To do this we'll start by adding a\nnew StringOperation class to our operations package. Given the recent additions, the package structure and classes\nshould look similar to the following:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"...\n[src]\n   [main]\n       [java]\n           [com.aardvark]\n               [config]\n                   AardvarkConfig.java\n               [operations]\n                   NumericOperation.java\n                   StringOperation.java\n               [tokens]\n                   [operators]\n                       AardvarkArithmeticOperator.java\n                       AardvarkComparisonOperator.java\n                   [literals]\n                       BooleanToken.java\n                       DecimalToken.java\n                       IntegerToken.java\n                       NullToken.java\n                       StringToken.java\n                   [statements]\n                       ExpressionToken.java\n               Application.java\n...\n")),(0,a.yg)("p",null,"In our operation class we define that either the first or second argument can be a String. This differs to other\noperation classes as you'd typically want them to be in that format i.e. Booleans or Numbers. In our case though\nwe can use the passed Tokens value and call the ",(0,a.yg)("inlineCode",{parentName:"p"},"toString()")," on it. As such, we can append whatever type it is\neither before or after our defined String."),(0,a.yg)("p",null,"We'll add support for 3 operators for use with our String type. These will be add, equal and not-equal. You are\nhowever free to add your own additional operators. For example, you could make use of subtract by removing all\ninstances of the right String from the original e.g. ",(0,a.yg)("inlineCode",{parentName:"p"},"'William' - 'iam'")," would result in ",(0,a.yg)("inlineCode",{parentName:"p"},"'Will'"),". This could\nbe done by using"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'    case SUBTRACT: return new StringToken(first.getValue().toString()\n                        .replace(second.getValue().toString(), ""));\n')),(0,a.yg)("p",null,"For this though, we'll keep things simple. It's worth noting here again that we're using multiple operator types.\nIf you do want to use a specific one, please ensure you are casting the ",(0,a.yg)("inlineCode",{parentName:"p"},"operator")," to the correct type."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class StringOperation implements TypeOperation {\n\n    @Override\n    public boolean canHandle(Token<?> first, OperatorHandler<?> operator, Token<?> second) {\n        //Other types (left or right side) are cast to Strings in operations\n        return first.is(String.class) || second.is(String.class);\n    }\n\n    @Override\n    public <T> T handleCustomOperator(Token<?> first, OperatorHandler<?> operator, Token<?> second) {\n        throw new ParserException(String.format(\"Unable to handle String operation with operator '%s'\",\n                operator.getValue()));\n    }\n\n    @Override\n    public Token<?> process(LARFConfig config, LARFContext context, Token<?> first, OperatorHandler<?> operator,\n                            Token<?> second, Token<?> leftSide) {\n        if (operator instanceof ArithmeticOperator) {\n            switch (((ArithmeticOperator)operator).getOpType()) {\n                case ADD: return new StringToken(first.getValue().toString()\n                        .concat(second.getValue().toString()));\n            }\n        } else if (operator instanceof ComparisonOperator) {\n            switch (((ComparisonOperator)operator).getOpType()) {\n                case EQUAL: return new BooleanToken(first.getValue(String.class)\n                        .equalsIgnoreCase(second.getValue(String.class)));\n                case NOT_EQUAL: return new BooleanToken(!first.getValue(String.class)\n                        .equalsIgnoreCase(second.getValue(String.class)));\n            }\n        }\n        return handleCustomOperator(first, operator, second);\n    }\n}\n\n")),(0,a.yg)("p",null,"Let's add our new operation class to the config:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class AardvarkConfig extends LARFConfig {\n    //...\n    @Override\n    protected TypeOperation initTypeOperations() {\n        addTypeOperation(new NumericOperation());\n        addTypeOperation(new StringOperation());\n        return null;\n    }\n    //...\n}\n")),(0,a.yg)("p",null,"Finally, let's run some examples:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"'hello ' + 'john'\nResult: hello john (Type: String, Time taken: 15ms)\n'William' - 'iam'\nResult: Will (Type: String, Time taken: 1ms)\n'abc' == 'abc'\nResult: true (Type: Boolean, Time taken: 1ms)\n'abc' == 'bdc'\nResult: false (Type: Boolean, Time taken: 1ms)\n'Johns age: ' + 41\nResult: Johns age: 41 (Type: String, Time taken: 1ms)\n")),(0,a.yg)("admonition",{title:"Mixing Types",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"The last example is mixing String's with Integer's, but this is not a problem as previously mentioned as we're\nusing the ",(0,a.yg)("inlineCode",{parentName:"p"},"toString()")," on the Tokens value. This allows us some flexibility without having to specifically\nhandle these scenarios.")))}d.isMDXComponent=!0}}]);