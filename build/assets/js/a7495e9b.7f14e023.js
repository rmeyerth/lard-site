"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[9521],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>g});var o=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=l(n),m=r,g=u["".concat(c,".").concat(m)]||u[m]||d[m]||a;return n?o.createElement(g,s(s({ref:t},p),{},{components:n})):o.createElement(g,s({ref:t},p))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[u]="string"==typeof e?e:r,s[1]=i;for(var l=2;l<a;l++)s[l]=n[l];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2608:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var o=n(8168),r=(n(6540),n(5680));const a={sidebar_position:3},s="Context",i={unversionedId:"toolkit/context",id:"toolkit/context",title:"Context",description:"Context",source:"@site/docs/toolkit/context.md",sourceDirName:"toolkit",slug:"/toolkit/context",permalink:"/docs/toolkit/context",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/toolkit/context.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Grammar",permalink:"/docs/toolkit/tokens/grammar"},next:{title:"Design Overview",permalink:"/docs/toolkit/design-overview"}},c={},l=[],p={toc:l},u="wrapper";function d(e){let{components:t,...a}=e;return(0,r.yg)(u,(0,o.A)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"context"},"Context"),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"Context",src:n(1837).A,width:"1468",height:"348"}),"\nThe context object is used primarily as storage and is accessible from any token via the ",(0,r.yg)("inlineCode",{parentName:"p"},"process")," method.\nIt can be pre-populated with objects prior to expressions being evaluated or loaded dynamically. When setting\nan object within the context, a unique name is specified which allows that reference to be used from within\nyour code. Here is an example of a simple language using standard object field notation against an object\nwhich has been stored in context:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'public static void main(String[] args) {\n    SLOPConfig config = new SLOPConfig();\n    LARFContext context = new LARFContext();\n    context.set("acme", sampleCompany());\n    LARFProcessor processor = new LARFProcessor(config);\n    System.out.println(processor.process("acme.employees[0].name", context).getValue(String.class));\n}\n')),(0,r.yg)("p",null,"When an object is stored dynamically from within a token, the context manages that objects state and scope\nto ensure access is not permitted where it shouldn't. It also supports recursion out of the box and will\nmaintain the state for each copy of a value. This is transparent to the developer and happens automatically\nusing the get / set methods found within the context object."),(0,r.yg)("p",null,"Here is a more complex example of context use:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'/**\n * This is where the function is passed parameters by the InvocationToken which is being evaluated. That \n * token retrieved this one from the heap using a concatenation between the function name and the number \n * of parameters. The passed parameters are written into context and the contained tokens evaluated. The \n * result is returned from the evaluation of these.\n * @param parser The parser used to resolve child token expressions\n * @param context The context for resolving object references\n * @param config The configuration for resolution of property values\n * @param providedParams The parameters from the calling InvocationToken\n * @return Returns the resulting value from the function execution\n */\npublic List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config, \n                              List<Token<?>> providedParams) {\n    String functionName = getTokenGroups().get(0).getFlatTokens().get(0).getValue().toString();\n    List<Token<?>> paramVars = getTokenGroups().get(1).getFlatTokens();\n    if (paramVars.size() != providedParams.size()) {\n        throw new ParserException(String.format("Function %s expected %d parameters, but only called with %d",\n                functionName, paramVars.size(), providedParams.size()));\n    }\n    for (int i = 0;i < paramVars.size();i++) {\n        context.set(paramVars.get(i).getValue(String.class), providedParams.get(i), VariableType.PARAMETER);\n    }\n    Token<?> result = parser.processExpression(getTokenGroups().get(3).getFlatTokens(), context);\n    if (!result.getParserFlags().isEmpty() && !result.getParserFlags().contains(ParserFlag.ERROR)) {\n        //Unwrap result as we don\'t want to return token any further\n        return Collections.singletonList(result.getValue() instanceof Token ?\n                (Token<?>)result.getValue() : new TokenValue(result.getValue()));\n    }\n    return Collections.singletonList(result);\n}\n')),(0,r.yg)("p",null,"The above method is an example which may exists on a languages function token and is called from the equivalent\nInvocationToken (see ",(0,r.yg)("a",{parentName:"p",href:"/docs/toolkit/tokens/functions"},"Functions")," for more information). Because this token represents the\nFunction being invoked, it is called with the parameters used to call it. The expected parameters are compared\nagainst the provided set - this is a typeless language so no need to check types - and if found to be a match,\neach parameters is set in context using it's name (from the function) and the value passed to this method. The\ncall to execute this is then passed to the parser and a result is returned and handled."),(0,r.yg)("p",null,"The context can be used to share context values between tokens to facilitate their execution, or store context\nobjects to be used in the code being executed. It's an easy class to use with a simplified set of methods, but\nremoves the complexity necessary when dealing with state, scope and more advanced features such as recursion."))}d.isMDXComponent=!0},1837:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/context-b74649222b8c98604b4be4a4eefc5dee.jpg"}}]);