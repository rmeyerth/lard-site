"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[3773],{5680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>y});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),u=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=u(e.components);return r.createElement(s.Provider,{value:n},e.children)},p="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(t),d=a,y=p["".concat(s,".").concat(d)]||p[d]||g[d]||o;return t?r.createElement(y,i(i({ref:n},c),{},{components:t})):r.createElement(y,i({ref:n},c))}));function y(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[p]="string"==typeof e?e:a,i[1]=l;for(var u=2;u<o;u++)i[u]=t[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9130:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var r=t(8168),a=(t(6540),t(5680));const o={sidebar_position:2},i="Speaking literally",l={unversionedId:"tutorial/speaking-literally",id:"tutorial/speaking-literally",title:"Speaking literally",description:"Integer Token",source:"@site/docs/tutorial/speaking-literally.md",sourceDirName:"tutorial",slug:"/tutorial/speaking-literally",permalink:"/docs/tutorial/speaking-literally",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial/speaking-literally.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"In the beginning...",permalink:"/docs/tutorial/in-the-beginning"},next:{title:"Modus operandi",permalink:"/docs/tutorial/modus-operandi"}},s={},u=[{value:"Integer Token",id:"integer-token",level:3},{value:"Regular Expression Explanation",id:"regular-expression-explanation",level:3},{value:"Numbers but...",id:"numbers-but",level:3}],c={toc:u},p="wrapper";function g(e){let{components:n,...t}=e;return(0,a.yg)(p,(0,r.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"speaking-literally"},"Speaking literally"),(0,a.yg)("h3",{id:"integer-token"},"Integer Token"),(0,a.yg)("p",null,"So, we've got a language that only contains null. Let's move on to adding numbers so that we can start to think\nabout resolving some basic calculations. For this we'll need to add a new token for Integers. Create a new token\ncalled IntegerToken in your project ",(0,a.yg)("inlineCode",{parentName:"p"},"tokens.literals")," folder and define the following:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'public class IntegerToken extends Token<Integer> {\n\n    public IntegerToken() { super("Integer", 0); }\n\n    public IntegerToken(Integer value) { super("Integer", value); }\n\n    @Override\n    public PatternType getPatternType() {\n        return PatternType.REGEX;\n    }\n\n    @Override\n    public String getPattern() {\n        return "^-?[0-9]+";\n    }\n\n    @Override\n    public Optional<String> getGuidance(String token, List<Integer> groupsCount) {\n        return Optional.empty();\n    }\n\n    @Override\n    public List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n        return Collections.singletonList(this);\n    }\n\n    @Override\n    public Token<Integer> createToken(String value) {\n        return new IntegerToken(Integer.parseInt(value));\n    }\n}\n')),(0,a.yg)("h3",{id:"regular-expression-explanation"},"Regular Expression Explanation"),(0,a.yg)("p",null,"This follows a very similar structure to the NullToken, but with a different regular expression pattern declared. In\nthis case we are declaring the starts with '^' character, followed by '-' (minus character), followed by a '?' which\nmakes the preceding character optional. Next we define a list of possible characters in a group to match. In this case\nwe want to match numeric digits in a String between 0 up to 9. The final '+' means we can have one or more of those.\nUsing this pattern we can define the full range of positive and negative integer values."),(0,a.yg)("p",null,"We've also added an overloaded version of the constructor which accepts an Integer value. This is because the Integer\ntoken deviates from the null as its value is mutable and can be set. It is actually used from the ",(0,a.yg)("inlineCode",{parentName:"p"},"createToken"),"\nmethod by converting the value from the expression String. So long as we've got the defined regular expression right,\nwe should have no conversion issues."),(0,a.yg)("p",null,"Again, let's add this to our configuration class:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class AardvarkConfig extends LARFConfig {\n    //...\n    @Override\n    protected void initTokenHandlers() {\n        addTokenHandler(new NullToken());\n        addTokenHandler(new IntegerToken());\n    }\n    //...\n}\n")),(0,a.yg)("h3",{id:"numbers-but"},"Numbers but..."),(0,a.yg)("p",null,"Launch our runner app and..."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"Aardvark Language Test Utility\n==============================\n-10\nResult: -10 (Type: Integer, Time taken: 19ms)\n10\nResult: 10 (Type: Integer, Time taken: 1ms)\n")),(0,a.yg)("p",null,"We now have simple Integer support in our language. Let's try to do a basic calculation:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"10 + 10\ndev.larf.exception.ParserException: Unexpected token '+' found in expression. Strict syntax checking is enabled\n    at dev.larf.lexer.LARFLexer.analysePatterns(LARFLexer.java:98)\n    at dev.larf.lexer.LARFLexer.tokenize(LARFLexer.java:57)\n    at dev.larf.lexer.Lexer.tokenize(Lexer.java:49)\n    at dev.larf.processor.LARFProcessor.process(LARFProcessor.java:82)\n    at dev.larf.runner.LARFRunner.run(LARFRunner.java:39)\n    at dev.larf.runner.LARFRunner.run(LARFRunner.java:10)\n    at dev.larf.runner.Application.main(Application.java:10)\n")),(0,a.yg)("p",null,"You knew it wasn't going to be that simple. Move onto the next section to learn about operators."))}g.isMDXComponent=!0}}]);