"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[4856],{5680:(e,n,t)=>{t.d(n,{xA:()=>u,yg:()=>m});var r=t(6540);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=r.createContext({}),p=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(l.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(t),g=o,m=d["".concat(l,".").concat(g)]||d[g]||c[g]||a;return t?r.createElement(m,i(i({ref:n},u),{},{components:t})):r.createElement(m,i({ref:n},u))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=g;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},4340:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var r=t(8168),o=(t(6540),t(5680));const a={sidebar_position:8},i="To be or not to be?",s={unversionedId:"tutorial/to-be-or-not-to-be",id:"tutorial/to-be-or-not-to-be",title:"To be or not to be?",description:"Ternary Conditional Statement",source:"@site/docs/tutorial/to-be-or-not-to-be.mdx",sourceDirName:"tutorial",slug:"/tutorial/to-be-or-not-to-be",permalink:"/docs/tutorial/to-be-or-not-to-be",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial/to-be-or-not-to-be.mdx",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Making a statement",permalink:"/docs/tutorial/make-a-statement"},next:{title:"A character study",permalink:"/docs/tutorial/a-character-study"}},l={},p=[{value:"Ternary Conditional Statement",id:"ternary-conditional-statement",level:3},{value:"Expanding our TypeOperation",id:"expanding-our-typeoperation",level:3},{value:"Testing Conditions",id:"testing-conditions",level:3},{value:"Logic in a Token?",id:"logic-in-a-token",level:3},{value:"Configure and Run",id:"configure-and-run",level:3}],u={toc:p},d="wrapper";function c(e){let{components:n,...t}=e;return(0,o.yg)(d,(0,r.A)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"to-be-or-not-to-be"},"To be or not to be?"),(0,o.yg)("h3",{id:"ternary-conditional-statement"},"Ternary Conditional Statement"),(0,o.yg)("p",null,"I'm sure we're all familiar with these. They generally take the form ",(0,o.yg)("inlineCode",{parentName:"p"},"condition ? trueResult : falseResult"),".\nWe've got several issues to overcome though. Namely, how can we define a condition when we have no way to compare\nvalues? More immediate though, how do we make LARF understand the condition result (Boolean)? Let's first start then\nby defining a BooleanToken. If you're feeling confident writing your own token using what you learned, go ahead and\ntry it yourself. Alternatively, click the spoiler below for help:"),(0,o.yg)("details",null,(0,o.yg)("summary",null,"BooleanToken Implementation"),(0,o.yg)("p",null,"First we define a new token called Boolean token in our ",(0,o.yg)("inlineCode",{parentName:"p"},"tokens.literals")," package:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"[src]\n   [main]\n       [java]\n           [com.aardvark]\n               [config]\n                   AardvarkConfig.java\n               [operations]\n                   IntegerOperation.java\n               [tokens]\n                   [operators]\n                       AardvarkArithmeticOperator.java\n                   [literals]\n                       BooleanToken.java\n                       DecimalToken.java\n                       IntegerToken.java\n                       NullToken.java\n                   [statements]\n                       ExpressionToken.java\n               Application.java\n")),(0,o.yg)("p",null,"Next, let's define our BooleanToken by extending Token and passing the Boolean generic type:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},'public class BooleanToken extends Token<Boolean> {\n\n    public BooleanToken() { super("Boolean", false); }\n\n    public BooleanToken(Boolean value) {\n        super("Boolean", value);\n    }\n\n    @Override\n    public PatternType getPatternType() {\n        return PatternType.REGEX;\n    }\n\n    @Override\n    public String getPattern() {\n        return "^(true|false)";\n    }\n\n    @Override\n    public Optional<String> getGuidance(String token, List<Integer> groupsCount) {\n        return Optional.empty();\n    }\n\n    @Override\n    public List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n        return Collections.singletonList(this);\n    }\n\n    @Override\n    public Token<Boolean> createToken(String value) {\n        return new BooleanToken(Boolean.parseBoolean(value));\n    }\n}\n')),(0,o.yg)("p",null,"Finally, let's add it to the configuration:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},"public class AardvarkConfig extends LARFConfig {\n    //...\n    @Override\n    protected void initTokenHandlers() {\n        //Literals\n        addTokenHandler(new NullToken());\n        addTokenHandler(new IntegerToken());\n        addTokenHandler(new DecimalToken());\n        addTokenHandler(new BooleanToken());\n\n        //Statements\n        addTokenHandler(new ExpressionToken());\n    }\n    //...\n}\n")),(0,o.yg)("p",null,"Test in the runner:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"true\nResult: true (Type: Boolean, Time taken: 18ms)\nfalse\nResult: false (Type: Boolean, Time taken: 1ms)\n"))),(0,o.yg)("p",null,"Now that we've defined and configured booleans, we need to think about a different set of Operators. If you remember\nback to the available operator sets, one of those was called the ComparisonOperator. Again, if you feel you know\nhow to do this using the AardvarkArithmeticOperator as a base, please do that. Alternatively, you can expand the\nspoiler again for help:"),(0,o.yg)("details",null,(0,o.yg)("summary",null,"AardvarkComparisonOperator Implementation"),(0,o.yg)("p",null,"Add a new class called AardvarkComparisonOperator.java to the ",(0,o.yg)("inlineCode",{parentName:"p"},"tokens.operators")," package."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"[src]\n   [main]\n       [java]\n           [com.aardvark]\n               [config]\n                   AardvarkConfig.java\n               [operations]\n                   IntegerOperation.java\n               [tokens]\n                   [operators]\n                       AardvarkArithmeticOperator.java\n                       AardvarkComparisonOperator.java\n                   [literals]\n                       BooleanToken.java\n                       DecimalToken.java\n                       IntegerToken.java\n                       NullToken.java\n                   [statements]\n                       ExpressionToken.java\n               Application.java\n")),(0,o.yg)("p",null,"Open up the new class and extend the ComparisonOperator template class. We'll stick with using the C / Java operators\nfor this:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},'public class AardvarkComparisonOperator extends ComparisonOperator {\n\n    public AardvarkComparisonOperator() {\n        super(null);\n    }\n\n    @Override\n    public Token<String> createToken(String value) {\n        return new AardvarkComparisonOperator();\n    }\n\n    @Override\n    public String getPattern() {\n        return "^(==|!=|>=|<=|>|<)";\n    }\n\n    @Override\n    protected void initOperators() {\n        addOperator("==", ComparisonOperatorType.EQUAL);\n        addOperator("!=", ComparisonOperatorType.NOT_EQUAL);\n        addOperator(">=", ComparisonOperatorType.GREATER_EQUAL_TO);\n        addOperator("<=", ComparisonOperatorType.LESS_EQUAL_TO);\n        addOperator(">", ComparisonOperatorType.GREATER_THAN);\n        addOperator("<", ComparisonOperatorType.LESS_THAN);\n    }\n\n    @Override\n    public String[][] getOperatorOrder() {\n        return new String[][] {\n                {">=", "<=", ">", "<"},\n                {"==", "!="}\n        };\n    }\n}\n')),(0,o.yg)("p",null,"Add the operator class to the configuration:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},"@Override\npublic class AardvarkConfig extends LARFConfig {\n    //...\n    @Override\n    protected void initOperators() {\n        addOperatorHandler(new AardvarkArithmeticOperator(null));\n        addOperatorHandler(new AardvarkComparisonOperator(null));\n    }\n    //...\n}\n"))),(0,o.yg)("h3",{id:"expanding-our-typeoperation"},"Expanding our TypeOperation"),(0,o.yg)("p",null,"We're one step closer to defining our statement. We've got the comparison operators defined and the result type. Let's\nsee what happens in the runner app:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"1 == 1\ndev.larf.exception.ParserException: Unable to handle numeric operation with operator '=='\n    at dev.larf.languages.aardvark.operations.NumericOperation.handleCustomOperator(NumericOperation.java:34)\n    at dev.larf.languages.aardvark.operations.NumericOperation.process(NumericOperation.java:53)\n    at dev.larf.parser.LARFParser.processOp(LARFParser.java:321)\n    at dev.larf.parser.LARFParser.processExpression(LARFParser.java:113)\n    at dev.larf.parser.LARFParser.process(LARFParser.java:44)\n    at dev.larf.processor.LARFProcessor.process(LARFProcessor.java:83)\n    at dev.larf.runner.LARFRunner.run(LARFRunner.java:39)\n    at dev.larf.runner.LARFRunner.run(LARFRunner.java:11)\n    at dev.larf.languages.aardvark.AardvarkRunner.main(AardvarkRunner.java:11)\n")),(0,o.yg)("p",null,"Yes, we need to update our NumericOperation class to handle those operators. Let's do that now:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},"public class NumericOperation implements TypeOperation {\n    //...\n    @Override\n    public Token<?> process(LARFConfig config, LARFContext context, Token<?> firstToken, OperatorHandler<?> operator,\n                            Token<?> secondToken, Token<?> leftSide) {\n        BigDecimal first = new BigDecimal(firstToken.getValue().toString());\n        BigDecimal second = new BigDecimal(secondToken.getValue().toString());\n        if (operator instanceof ArithmeticOperator) {\n            switch (((ArithmeticOperator)operator).getOpType()) {\n                case DIVIDE: return convert(first.divide(second, 6, RoundingMode.HALF_UP));\n                case ADD: return convert(first.add(second));\n                case SUBTRACT: return convert(first.subtract(second));\n                case MULTIPLY: return convert(first.multiply(second));\n                case MODULO: return convert(first.remainder(second));\n                default: return handleCustomOperator(firstToken, operator, secondToken);\n            }\n        } else if (operator instanceof ComparisonOperator) {\n            switch (((ComparisonOperator)operator).getOpType()) {\n                case GREATER_EQUAL_TO: return new BooleanToken(first.compareTo(second) >= 0);\n                case LESS_EQUAL_TO: return new BooleanToken(first.compareTo(second) <= 0);\n                case NOT_EQUAL: return new BooleanToken(first.compareTo(second) != 0);\n                case EQUAL: return new BooleanToken(first.compareTo(second) == 0);\n                case GREATER_THAN: return new BooleanToken(first.compareTo(second) > 0);\n                case LESS_THAN: return new BooleanToken(first.compareTo(second) < 0);\n            }\n        }\n        return handleCustomOperator(firstToken, operator, secondToken);\n    }\n    //...\n}\n")),(0,o.yg)("h3",{id:"testing-conditions"},"Testing Conditions"),(0,o.yg)("p",null,"In the case of the comparison operators, we can simply return the result as a BooleanToken with no need to use the\nwrap method. Let's run some tests:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"4 + 4 <= 6 + 2\nResult: true (Type: Boolean, Time taken: 19ms)\n10 == 5 + 5\nResult: true (Type: Boolean, Time taken: 1ms)\n3 < 4\nResult: true (Type: Boolean, Time taken: 1ms)\n9 > 10\nResult: false (Type: Boolean, Time taken: 1ms)\n13 != 13\nResult: false (Type: Boolean, Time taken: 1ms)\n")),(0,o.yg)("h3",{id:"logic-in-a-token"},"Logic in a Token?"),(0,o.yg)("p",null,"Great, so we've got the condition portion of our statement covered. Let's write our statement class. Add a new token\ncalled TernaryConditionalToken.java (or in my case ConditionalToken.java) to the ",(0,o.yg)("inlineCode",{parentName:"p"},"tokens.statements")," package. We'll\nthen define the class as such:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},'public class ConditionalToken extends Token<Void> {\n\n    public ConditionalToken() {\n        super("Conditional", null);\n    }\n\n    @Override\n    public PatternType getPatternType() {\n        return PatternType.GRAMMAR;\n    }\n\n    @Override\n    public String getPattern() {\n        return "expr \'?\' expr \':\' expr";\n    }\n\n    @Override\n    public Optional<String> getGuidance(String token, List<Integer> groupsCount) {\n        if (token.equalsIgnoreCase(":"))\n            return Optional.of("A conditional requires true / false outcomes to be separated by a \':\' " +\n                    "e.g. a > b ? a :<-- b");\n        return Optional.empty();\n    }\n\n    @Override\n    public List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n        //Expect that there are 3 tokens groups representing the condition and true / false token groups\n        if (getTokenGroups().size() < 3) {\n            String found = getTokenGroups().stream().map(Token::toSimpleString).collect(Collectors.joining(","));\n            throw new ParserException(String.format("Condition does not have required arguments to execute. Expecting " +\n                    "3 groups being condition, trueResult and falseResult. Found: [%s]", found));\n        }\n        //Evaluate the condition using the tokens found in the first token group\n        Token<?> conditionResult = parser.processExpression(getTokenGroups().get(0).getTokens(), context);\n        //If the condition is not a Boolean then throw an error i.e. "1 + 2 ? 3 : 4"\n        if (!(conditionResult instanceof BooleanToken)) {\n            throw new ParserException(String.format("Expected a boolean result from condition \'%s\'. Possible invalid " +\n                            "condition specified", getTokenGroups().get(0)));\n        }\n        //Execute the relevant set of tokens based on the condition result\n        return Collections.singletonList((((BooleanToken) conditionResult).getValue()) ?\n                parser.processExpression(getTokenGroups().get(1).getFlatTokens(), context) :\n                parser.processExpression(getTokenGroups().get(2).getFlatTokens(), context));\n    }\n\n    @Override\n    public Token<Void> createToken(String value) {\n        return cloneDefaultProperties(new ConditionalToken());\n    }\n\n    @Override\n    public String toString() {\n        return "Conditional{" +\n                "condition=" + (!getTokenGroups().isEmpty() ? getTokenGroups().get(0) : null) +\n                ", trueResult=" + (getTokenGroups().size() > 1 ? getTokenGroups().get(1) : null) +\n                ", falseResult=" + (getTokenGroups().size() > 2 ? getTokenGroups().get(2) : null) +\n                \'}\';\n    }\n}\n')),(0,o.yg)("p",null,"Ok, that's a big chunk of code but let's break it down:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"The pattern now defines three capture groups of one or more tokens. This means we can do something like\n",(0,o.yg)("inlineCode",{parentName:"li"},"1 + 2 > 3 ? 4 + 4 : 3 / 2"),". After the first capture group we're expecting a '?' character with a ':' expected\nbetween true / false cases."),(0,o.yg)("li",{parentName:"ol"},"We have one guidance condition if a user defines the first and second capture including the '?' value, but no\nsubsequent ':' is defined, this will trigger this scenario."),(0,o.yg)("li",{parentName:"ol"},"The process is actually quite straightforward. Since the pattern has defined three capture groups, if there are\nless than 3 returned by the lexer then we throw an exception. The next line:",(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-java"},"Token<?> conditionResult = parser.processExpression(getTokenGroups().get(0).getTokens(), context);\n")),"Passes evaluation of the condition (the first token group) back to the parser for a result. We then check to see\nif the result is a BooleanToken, otherwise we'll throw an error. For example, defining ",(0,o.yg)("inlineCode",{parentName:"li"},"1 + 1 ? 1 : 2")," would\ncause this error to be thrown. I've aggregated a few steps into the final line, but effectively we evaluate the\nresult of the condition using Java's own ternary condition operator. In each scenario, we pass the relevant\ntoken group to the parser for evaluation and return the result in a list."),(0,o.yg)("li",{parentName:"ol"},"I've overridden the ",(0,o.yg)("inlineCode",{parentName:"li"},"toString()")," here as it's useful to do this for debugging purposes. It makes the content\nof the token easier tor read.")),(0,o.yg)("h3",{id:"configure-and-run"},"Configure and Run"),(0,o.yg)("p",null,"Ok, let's add our new Token as a new token handler to the configuration:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},"public class AardvarkConfig extends LARFConfig {\n    //...\n    @Override\n    protected void initTokenHandlers() {\n        //Literals\n        addTokenHandler(new NullToken());\n        addTokenHandler(new IntegerToken());\n        addTokenHandler(new DecimalToken());\n        addTokenHandler(new BooleanToken());\n\n        //Statements\n        addTokenHandler(new ExpressionToken());\n        addTokenHandler(new ConditionalToken());\n    }\n    //...\n}\n")),(0,o.yg)("p",null,"Let's try evaluating some conditionals:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"3 > 4 ? 1 : 2\nResult: 2 (Type: Integer, Time taken: 22ms)\n4 > 3 ? 1 : 2\nResult: 1 (Type: Integer, Time taken: 3ms)\n1 + (3 * 2) > 9 - 2 ? 1 : 2\nResult: 2 (Type: Integer, Time taken: 4ms)\n")))}c.isMDXComponent=!0}}]);