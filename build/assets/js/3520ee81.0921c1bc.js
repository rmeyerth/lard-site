"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[9562],{5680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>f});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=r.createContext({}),l=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=l(e.components);return r.createElement(p.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=l(t),g=a,f=u["".concat(p,".").concat(g)]||u[g]||d[g]||o;return t?r.createElement(f,i(i({ref:n},c),{},{components:t})):r.createElement(f,i({ref:n},c))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=g;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},8456:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=t(8168),a=(t(6540),t(5680));const o={sidebar_position:5},i="Type Operations",s={unversionedId:"tutorial/type-operations",id:"tutorial/type-operations",title:"Type Operations",description:"TypeOperation Class",source:"@site/docs/tutorial/type-operations.mdx",sourceDirName:"tutorial",slug:"/tutorial/type-operations",permalink:"/docs/tutorial/type-operations",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial/type-operations.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Modus operandi",permalink:"/docs/tutorial/modus-operandi"},next:{title:"Point of decimals",permalink:"/docs/tutorial/point-of-decimals"}},p={},l=[{value:"TypeOperation Class",id:"typeoperation-class",level:3},{value:"Integer Operation",id:"integer-operation",level:3},{value:"Configure and... not quite",id:"configure-and-not-quite",level:3}],c={toc:l},u="wrapper";function d(e){let{components:n,...t}=e;return(0,a.yg)(u,(0,r.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"type-operations"},"Type Operations"),(0,a.yg)("h3",{id:"typeoperation-class"},"TypeOperation Class"),(0,a.yg)("p",null,"Let's create a new package called operations and create a new token called IntegerOperation.java:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"[src]\n   [main]\n       [java]\n           [com.aardvark]\n               [config]\n                   AardvarkConfig.java\n               [operations]\n                   IntegerOperation.java\n               [tokens]\n                   [operators]\n                       AardvarkArithmeticOperator.java\n                   [literals]\n                       IntegerToken.java\n                       NullToken.java\n               Application.java\n")),(0,a.yg)("p",null,"Our class will extend TypeOperation where we're required to implement 3 methods. These are ",(0,a.yg)("inlineCode",{parentName:"p"},"canHandle"),",\n",(0,a.yg)("inlineCode",{parentName:"p"},"handleCustomOperator")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"process"),". The canHandle determines whether the current operation class can handle\nwhatever is being executed by the parser. We will return true if both the first and second tokens represent Integers\nby using ",(0,a.yg)("inlineCode",{parentName:"p"},"aToken.is(Integer.class)"),". The second method (handleCustomOperator) acts as a fallback and only gets called\nif no match was found. This is triggered if you don't define an action for all the operators within our ArithmeticOperator\nclass."),(0,a.yg)("p",null,"The process method is where we write the code to handle each operator for the supported types. We first extract each\nToken value using the ",(0,a.yg)("inlineCode",{parentName:"p"},"getValue(Class<?> aClass)")," method. We then map the operator to a specific operator set\n(ArithmeticOperator in our case) and return the result of each operation. The ",(0,a.yg)("inlineCode",{parentName:"p"},"wrap")," method simply wraps the result\nin our Token class we defined earlier."),(0,a.yg)("h3",{id:"integer-operation"},"Integer Operation"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class IntegerOperation implements TypeOperation {\n\n    @Override\n    public boolean canHandle(Token<?> first, OperatorHandler<?> operator, Token<?> second) {\n        return first.is(Integer.class) && second.is(Integer.class);\n    }\n\n    @Override\n    public <T> T handleCustomOperator(Token<?> first, OperatorHandler<?> operator, Token<?> second) {\n        throw new ParserException(String.format(\"Unable to handle integer operation with operator '%s'\",\n                operator.getValue()));\n    }\n\n    @Override\n    public Token<?> process(LARFConfig config, LARFContext context, Token<?> firstToken, OperatorHandler<?> operator,\n                            Token<?> secondToken, Token<?> leftSide) {\n        //Extract token values\n        Integer first = firstToken.getValue(Integer.class);\n        Integer second = secondToken.getValue(Integer.class);\n        //Check that operator is Arithmetic and handle each case using switch\n        if (operator instanceof ArithmeticOperator) {\n            switch (((ArithmeticOperator)operator).getOpType()) {\n                case ADD: return wrap(first + second);\n                case SUBTRACT: return wrap(first - second);\n                case DIVIDE: return wrap(first / second);\n                case MULTIPLY: return wrap(first * second);\n                case MODULO: return wrap(first % second);\n            }\n        }\n        //Fallback\n        return handleCustomOperator(firstToken, operator, secondToken);\n    }\n\n    private Token<?> wrap(Integer result) {\n        return new IntegerToken(result);\n    }\n}\n")),(0,a.yg)("h3",{id:"configure-and-not-quite"},"Configure and... not quite"),(0,a.yg)("p",null,"Next we add this to our config class:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"@Override\npublic class AardvarkConfig extends LARFConfig {\n    //...\n    @Override\n    protected TypeOperation initTypeOperations() {\n        addTypeOperation(new IntegerOperation());\n        return null;\n    }\n    //...\n}\n")),(0,a.yg)("p",null,"We'll return null from the initTypeOperations method for now. This simply states which type operation will be used as a\nfallback should no other match be found. Now we have this, let's test out some basic calculations in our runner:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"10 + 10\nResult: 20 (Type: Integer, Time taken: 11ms)\n10 / 2\nResult: 5 (Type: Integer, Time taken: 1ms)\n10 % 3\nResult: 1 (Type: Integer, Time taken: 1ms)\n1 + 6 / 3 + 1\nResult: 4 (Type: Integer, Time taken: 2ms)\n")),(0,a.yg)("p",null,"It's working! However not everything's perfect with our language. Take the following example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"3 / 2\nResult: 1 (Type: Integer, Time taken: 0ms)\n")),(0,a.yg)("p",null,"That's not quite right. Shouldn't a decimal value of 1.5 be returned? Well, since we haven't defined what a decimal is,\nhow can one be returned? As such, let's get this fixed in the next section."))}d.isMDXComponent=!0}}]);