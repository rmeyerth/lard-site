"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[3515],{5680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>h});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),u=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=u(e.components);return r.createElement(s.Provider,{value:n},e.children)},p="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(t),d=a,h=p["".concat(s,".").concat(d)]||p[d]||g[d]||i;return t?r.createElement(h,o(o({ref:n},c),{},{components:t})):r.createElement(h,o({ref:n},c))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[p]="string"==typeof e?e:a,o[1]=l;for(var u=2;u<i;u++)o[u]=t[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},8026:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>g,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var r=t(8168),a=(t(6540),t(5680));const i={sidebar_position:2},o="In the beginning...",l={unversionedId:"tutorial/in-the-beginning",id:"tutorial/in-the-beginning",title:"In the beginning...",description:"The Void",source:"@site/docs/tutorial/in-the-beginning.mdx",sourceDirName:"tutorial",slug:"/tutorial/in-the-beginning",permalink:"/docs/tutorial/in-the-beginning",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial/in-the-beginning.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/docs/tutorial/getting-started"},next:{title:"Speaking literally",permalink:"/docs/tutorial/speaking-literally"}},s={},u=[{value:"The Void",id:"the-void",level:3},{value:"Token Class",id:"token-class",level:3},{value:"Configure and Run",id:"configure-and-run",level:3}],c={toc:u},p="wrapper";function g(e){let{components:n,...t}=e;return(0,a.yg)(p,(0,r.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"in-the-beginning"},"In the beginning..."),(0,a.yg)("h3",{id:"the-void"},"The Void"),(0,a.yg)("admonition",{title:"Starter projects",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"This tutorial will take you through step-by-step on how to create literals and operators. If you'd prefer to skip ahead\n(though if this is your first project I'd recommend continuing), then you can download one of the starter projects\nwhich contain a set of default literals and operators to get you started ",(0,a.yg)("a",{parentName:"p",href:"/docs/examples/starter-projects/starter"},"here"),".")),(0,a.yg)("p",null,"In the beginning there is nothing... or in our case ",(0,a.yg)("strong",{parentName:"p"},"null"),". Alas, since we haven't defined what null is we don't even\nhave that yet! We can test this by typing null in our runner app:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"Aardvark Language Test Utility\n===============================\nnull\ndev.larf.exception.ParserException: Unexpected token 'null' found in expression. Strict syntax checking is enabled\n    at dev.larf.lexer.LARFLexer.analysePatterns(LARFLexer.java:98)\n    at dev.larf.lexer.LARFLexer.tokenize(LARFLexer.java:57)\n    at dev.larf.lexer.Lexer.tokenize(Lexer.java:49)\n    at dev.larf.processor.LARFProcessor.process(LARFProcessor.java:82)\n    at dev.larf.runner.LARFRunner.run(LARFRunner.java:39)\n    at dev.larf.runner.LARFRunner.run(LARFRunner.java:10)\n    at dev.larf.runner.Application.main(Application.java:10)\n")),(0,a.yg)("h3",{id:"token-class"},"Token Class"),(0,a.yg)("p",null,"As such, this will be our first task. Create a new package called tokens. Within that add another package called\nliterals and add a new file called NullToken.java:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"[src]\n   [main]\n       [java]\n           [com.aardvark]\n               [config]\n                   AardvarkConfig.java\n               [tokens]\n                   [literals]\n                       NullToken.java\n               Application.java\n")),(0,a.yg)("p",null,"Open up the new token class and add ",(0,a.yg)("inlineCode",{parentName:"p"},"extends Token<Void>")," after the class name. As with the configuration file,\nthis will inherit a number of methods to implement from the parent class. These can be seen here:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class NullToken extends Token<Void> {\n\n  @Override\n  public Token<Void> createToken(String value) {\n    return null;\n  }\n\n  @Override\n  public PatternType getPatternType() {\n    return null;\n  }\n\n  @Override\n  public String getPattern() {\n    return null;\n  }\n\n  @Override\n  public Optional<String> getGuidance(String token, List<Integer> groupsCount) {\n    return Optional.empty();\n  }\n\n  @Override\n  protected List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n    return null;\n  }\n}\n")),(0,a.yg)("p",null,"I'll briefly run through the features of this class before diving in. Firstly, you'll notice that the Token class\nwe are extending always requires a generic type. This determines the type each token will represent / store as a value.\nIn our case, since there is no Null type in Java, we can use Void. Here is a description of the other functions in\nthe class:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"createToken"),": Gets called when the lexer matches this tokens pattern against the beginning of the expression. It\nreturns a new instance with the function parameter being the matched value. In this case it's null so we can just invoke\nthe blank constructor as we won't store it."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"getPatternType"),": This is an enum representing the pattern type for the current token. This has two possible values\nbeing either REGEX or GRAMMAR. For simple literals (Integer, Float, Double, String etc) these can be matched using\nregular expressions. For more complex structures like statements or collections, those use grammar."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"getPattern"),": Dependent on the pattern type, this will either contain a regular expression or a grammar definition.\nFor example, to define our null keyword we'll be using \"^null\" or \"^nil\" (whatever you prefer). As the expression is\nprocessed, its matched against what's left of the unprocessed expression String. The '^' before the keyword simply\nmeans that this is matched against the beginning of the String."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"getGuidance"),": This is used when we start defining statements. If the expression is not valid and the current active\nstatement is still waiting for a given token, we can provide them a message here to show them where they made the mistake\nand how to fix it."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"process"),": During expression resolution, this gets called by the parser and this is where the bulk of our language\ncode will go. For literals though like null, you will simply return the current token as-is.")),(0,a.yg)("p",null,"Given the above, we can now populate our token with the following:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'public class NullToken extends Token<Void> {\n\n  public NullToken() {\n    super("null", null);\n  }\n\n  @Override\n  public PatternType getPatternType() {\n    return PatternType.REGEX;\n  }\n\n  @Override\n  public String getPattern() {\n    return "^null";\n  }\n\n  @Override\n  public Optional<String> getGuidance(String token, List<Integer> groupsCount) {\n    return Optional.empty();\n  }\n\n  @Override\n  public List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n    return Collections.singletonList(this);\n  }\n\n  @Override\n  public Token<Void> createToken(String value) {\n    return new NullToken();\n  }\n}\n')),(0,a.yg)("h3",{id:"configure-and-run"},"Configure and Run"),(0,a.yg)("p",null,"We have also defined a constructor which calls the parent. This call sets a unique name for the token and specifies a\nvalue for the token, in this case it is just null. Congratulations, we have our first token! Now all we need to do is\nadd it to our configuration:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class AardvarkConfig extends LARFConfig {\n  //...\n  @Override\n  protected void initTokenHandlers() {\n    addTokenHandler(new NullToken());\n  }\n  //...\n}\n")),(0,a.yg)("p",null,"Go back to our runner, and..."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"Aardvark Language Test Utility\n===============================\nnull\nResult: null (Type: Null, Time taken: 19ms)\n")),(0,a.yg)("p",null,"we get null being returned when it is typed in. Nothing too exciting, but something that is necessary to have in most\nlanguages. If you were wondering, don't worry too much about the performance for this first call. You'll notice\nrepeated or different expressions revert to 1 millisecond or less. This is caused by the overhead of Java loading\nthe classes and resources for the first time."))}g.isMDXComponent=!0}}]);