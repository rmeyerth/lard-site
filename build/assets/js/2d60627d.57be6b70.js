"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[4878],{5680:(e,n,t)=>{t.d(n,{xA:()=>g,yg:()=>m});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},g=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,g=l(e,["components","mdxType","originalType","parentName"]),u=p(t),c=a,m=u["".concat(s,".").concat(c)]||u[c]||d[c]||o;return t?r.createElement(m,i(i({ref:n},g),{},{components:t})):r.createElement(m,i({ref:n},g))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},9359:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=t(8168),a=(t(6540),t(5680));const o={sidebar_position:10},i="Grammar",l={unversionedId:"toolkit/tokens/grammar",id:"toolkit/tokens/grammar",title:"Grammar",description:"Grammar",source:"@site/docs/toolkit/tokens/grammar.md",sourceDirName:"toolkit/tokens",slug:"/toolkit/tokens/grammar",permalink:"/docs/toolkit/tokens/grammar",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/toolkit/tokens/grammar.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Callbacks",permalink:"/docs/toolkit/tokens/callbacks"},next:{title:"Context",permalink:"/docs/toolkit/context"}},s={},p=[{value:"Kotlin - Elvis Operator (Easy)",id:"kotlin---elvis-operator-easy",level:3},{value:"C++ - If Statement (Medium)",id:"c---if-statement-medium",level:3}],g={toc:p},u="wrapper";function d(e){let{components:n,...o}=e;return(0,a.yg)(u,(0,r.A)({},g,o,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"grammar"},"Grammar"),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"Grammar",src:t(3343).A,width:"1471",height:"304"}),"\nThe grammar system allows you to outline the pattern the lexer it should match for your statement when tokenizing an\nexpression. It also tells the lexer the groups to which tokens should be assigned so that they are accessible during\nparsing when your Token ",(0,a.yg)("inlineCode",{parentName:"p"},"process")," method gets called. During its development it became fondly known as the Least\nEffort Grammar System (LEGS for short). This is because you don't have to outline every possible interaction between\nsets of tokens. Instead we give it the basic structure, state what will be captured at a given point and the Lexer\nwill figure out the rest. Below is a table showing the symbols you can use within the grammar and what they do:"),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Symbol"),(0,a.yg)("th",{parentName:"tr",align:null},"Example"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"'...'"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"'for'")),(0,a.yg)("td",{parentName:"tr",align:null},"A static syntax value")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"expr"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"expr")),(0,a.yg)("td",{parentName:"tr",align:null},"A capture group of one or more tokens")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"val"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"val")),(0,a.yg)("td",{parentName:"tr",align:null},"A capture group of strictly one token")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"?"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"expr?")),(0,a.yg)("td",{parentName:"tr",align:null},"Makes the preceding group or token optional")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"<?"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"'!'<?")),(0,a.yg)("td",{parentName:"tr",align:null},"Stores the static syntax value to the group. This can be used as a flag so that if the value is used it can be used by the code during processing.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"(...)"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"( expr )")),(0,a.yg)("td",{parentName:"tr",align:null},"Defines a token group so that actions can be applied against the contents. It also provides the ability to create multiple levels of tokens groups for complex structures.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"+"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"( expr ',' )+")),(0,a.yg)("td",{parentName:"tr",align:null},"Flags that the previous token group can occur multiple times")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"[...]"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"[ ref1, ref2 ]")),(0,a.yg)("td",{parentName:"tr",align:null},"Grammar references defer responsibility to one or more other tokens to handle execution. This allows grammar branching so one token can support multiple implementation e.g. for / foreach both using the same ",(0,a.yg)("inlineCode",{parentName:"td"},"for")," keyword.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},":"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"val:String")),(0,a.yg)("td",{parentName:"tr",align:null},"Used in conjunction with a single capture group. This forces a given value to adhere to the provided name / type specified.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"type"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"type")),(0,a.yg)("td",{parentName:"tr",align:null},"Captures a type when defining a typed language. Types can be used when defining variables, return types of methods / classes or generics. Literals representing types should implement the TypedToken interface.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"mod"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"( mod )+?")),(0,a.yg)("td",{parentName:"tr",align:null},"Modifiers are used to change the immutability or visibility of a variable, function or type. These tokens implement the TokenModifier interface.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"error"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"error")),(0,a.yg)("td",{parentName:"tr",align:null},"Captures an error handler which is thrown by the resources upon which it is defined.")))),(0,a.yg)("p",null,"Let's look at a couple of examples from various languages to see how we would define them and how they get mapped to token groups."),(0,a.yg)("h3",{id:"kotlin---elvis-operator-easy"},"Kotlin - Elvis Operator (Easy)"),(0,a.yg)("p",null,"In Kotlin, including several other languages there is the elvis operator. This is the equivalent of what the\nOptional.ofNullable does in Java. An example of this would be ",(0,a.yg)("inlineCode",{parentName:"p"},'customerAges.get("mary") ?: -1'),". It looks at the value of the\nleft-side and if found to be null, uses the right-side as a fallback. The grammar for this in LARF would be:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"@Override\npublic String getPattern() {\n    return \"val '?:' val\";\n}\n")),(0,a.yg)("p",null,"Alternatively you could replace the ",(0,a.yg)("inlineCode",{parentName:"p"},"val")," with ",(0,a.yg)("inlineCode",{parentName:"p"},"expr")," for the fallback portion which would provide\nsupport for multiple token evaluation e.g. ",(0,a.yg)("inlineCode",{parentName:"p"},"possibleNull ?: fallback + 2"),". Now that we have our grammar, let's look\nat this in terms of token groups. In this simple example there are only two, which is the value being evaluated and\nthe fallback. Since we now know this, we can write our process method as the following:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'@Override\npublic List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n    if (getTokenGroups().size() != 2) {\n        throw new ParserException(String.format("Expected both a value to check for null and a fallback. " +\n                "Found %s tokens", getTokenGroups().size()));\n    }\n    Token<?> result = parser.processExpression(getTokenGroups().get(0).getTokens(), context);\n    if (Objects.isNull(result.getValue())) {\n        return Collections.singletonList(\n                parser.processExpression(getTokenGroups().get(1).getTokens(), context));\n    }\n    return Collections.singletonList(result);\n}\n')),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"First we check to see if we have two token groups. If not we can throw a parser error."),(0,a.yg)("li",{parentName:"ol"},"Next we evaluate the content of the first token group. If the left-side is null, evaluate and return the content of\nthe fallback group. Alternatively just return the result.")),(0,a.yg)("admonition",{title:"Verifying Token Groups",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"Although it is good practise to verify token content during the processing phase, many issues would typically be\ncaught by the syntax checker and throw an error during the lexing stage. Still, for safety and to prevent any\nunforeseen issues, it is always best to verify the groups you're expecting are present before using them.")),(0,a.yg)("h3",{id:"c---if-statement-medium"},"C++ - If Statement (Medium)"),(0,a.yg)("p",null,"A common statement across all languages is the conditional of ",(0,a.yg)("inlineCode",{parentName:"p"},"if")," statement. It evaluates a boolean condition and\nexecutes one or more statements or expressions. It could include an alternative group of expressions to execute using\nan ",(0,a.yg)("inlineCode",{parentName:"p"},"else")," which could be chained with other ",(0,a.yg)("inlineCode",{parentName:"p"},"if")," statements. Although the nature of this statement is simple, there\nis actually a branch in the body. This is because we could do ",(0,a.yg)("inlineCode",{parentName:"p"},"if (i == 1) j = 4;")," or we could have multiple lines\nin a code-block:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"int j, j;\nif (i == 1) {\n    i = j;\n    j += 2;\n}\n")),(0,a.yg)("p",null,"To handle both from within the same statement, we can define the following:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"@Override\npublic String getPattern() {\n    return \"'if' '(' expr ')' [ singleLine, multiLine ] ( 'else' [ singleLine, multiLine ] )?\";\n}\n")),(0,a.yg)("p",null,"Let's break this down:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"First we expect an ",(0,a.yg)("inlineCode",{parentName:"li"},"if")," keyword"),(0,a.yg)("li",{parentName:"ol"},"Next an expression (one or more tokens) wrapped in syntax parentheses e.g. ",(0,a.yg)("inlineCode",{parentName:"li"},"'(' ... ')'"),"."),(0,a.yg)("li",{parentName:"ol"},"We have our first branch which defers responsibility to a token identified by the name ",(0,a.yg)("inlineCode",{parentName:"li"},"singleLine")," or ",(0,a.yg)("inlineCode",{parentName:"li"},"multiLine"),"."),(0,a.yg)("li",{parentName:"ol"},"Finally we declare another optional group for the ",(0,a.yg)("inlineCode",{parentName:"li"},"else")," portion with yet another single or multi-line body")),(0,a.yg)("p",null,"Before we dive into look at the single and multi-line tokens, let's look at the process method implementation for this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'@Override\npublic List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n    Token<?> condition = parser.processExpression(getTokenGroups().get(0).getFlatTokens(), context);\n    if (!condition.is(Boolean.class)) {\n        throw new ParserException("If requires a boolean to be used as a the condition!");\n    }\n    if (Boolean.TRUE.equals(condition.getValue(Boolean.class))) {\n        return Collections.singletonList(parser.processExpression(getTokenGroups().get(1).getFlatTokens(), context));\n    } else if (getTokenGroups().size() == 3) {\n        return Collections.singletonList(parser.processExpression(getTokenGroups().get(2).getFlatTokens(), context));\n    }\n    return Collections.singletonList(config.getNullToken());\n}\n')),(0,a.yg)("p",null,"Let's again break this down:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Although it might not be clear to see, there are in fact 3 resulting token groups from the above grammar string.\nThe first is the condition with the second and third being the two possible grammar reference branches (true or false)\nscenarios."),(0,a.yg)("li",{parentName:"ol"},"The code evaluates the content of the first token group"),(0,a.yg)("li",{parentName:"ol"},"If the result is not a Boolean then an error is thrown"),(0,a.yg)("li",{parentName:"ol"},"If the result is true then the second token group is evaluated"),(0,a.yg)("li",{parentName:"ol"},"If the condition evaluates to false then we check to see if there are 3 token groups and evaluate that group.\nAlternatively a null token is returned as nothing needs to be done.")),(0,a.yg)("p",null,"Before we dive in and start looking at the single and multi-line token variants, there is one more thing to be aware of.\nTokens by default are created as TokenType.PRIMARY. This means it is added to the list so that it can be matched directly\nfrom the keywords found in code. The alternative to this is TokenType.SECONDARY which cannot be instantiated from code\nalone and must exist as part of another Token. An example of this is the MultiLineToken (as referenced above). In C / C++\nor Java you cannot define ",(0,a.yg)("inlineCode",{parentName:"p"},"{ ... }")," on their own, but only as part of another token. Whether that is a condition,\nfunction or class. Now that we know this, let's look at the SingleLineToken implementation:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'public class SingleLineToken extends Token<Void> {\n\n    public SingleLineToken() {\n        super("singleLine", null);\n    }\n\n    @Override\n    public PatternType getPatternType() {\n        return PatternType.GRAMMAR;\n    }\n\n    @Override\n    public String getPattern() {\n        return "expr \';\'";\n    }\n\n    @Override\n    public List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n        if (getTokenGroups().isEmpty())\n            return Collections.singletonList(config.getNullToken());\n        //Fetch all inner tokens within line to process\n        List<Token<?>> tokens = getTokenGroups().get(0).getFlatTokens();\n        return Collections.singletonList(parser.processExpression(tokens, context));\n    }\n\n    @Override\n    public Token<Void> createToken(String value) {\n        return cloneDefaultProperties(new SingleLineToken());\n    }\n\n    @Override\n    public boolean isExpression() {\n        return true;\n    }\n}\n')),(0,a.yg)("p",null,"We can see that when we create a Token, the superclass constructor must be called which requires a name and value.\nThis is where we can see our unique reference for our token that can be used in grammar references. Here are some\nobservations about the class:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"The SingleLineToken is TokenType.PRIMARY rather than SECONDARY. This is because we define use it on it's own by\ndefining ",(0,a.yg)("inlineCode",{parentName:"li"},"int i = 1 + 2;"),". It needs no other token to exist."),(0,a.yg)("li",{parentName:"ol"},"In our case, the grammar for this is very simple with one or more tokens being defined, ending with a ';' character."),(0,a.yg)("li",{parentName:"ol"},"Moving into our process method, if no token groups are found then a NullToken is returned."),(0,a.yg)("li",{parentName:"ol"},"If a token group does exist, we evaluate and return the result from token group 0 and return it."),(0,a.yg)("li",{parentName:"ol"},"Because this Token is used to hold expressions, we need to override the ",(0,a.yg)("inlineCode",{parentName:"li"},"isExpression")," method and return true.\nThis flag for special handling by the Lexer and Parser.")),(0,a.yg)("p",null,"Let's now contrast this with our MultiLineToken:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class MultiLineToken extends Token<Void> {\n\n    public MultiLineToken() {\n        super(\"multiLine\", null, TokenType.SECONDARY);\n    }\n\n    @Override\n    public PatternType getPatternType() {\n        return PatternType.GRAMMAR;\n    }\n\n    @Override\n    public String getPattern() {\n        return \"'{' ( [ singleLine ] )+ '}'\";\n    }\n\n    @Override\n    public Optional<String> getGuidance(String token, List<Integer> groupsCount) {\n        return Optional.empty();\n    }\n\n    @Override\n    public List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n        if (getTokenGroups().isEmpty()) return Collections.singletonList(new NullToken());\n        List<Token<?>> singleLines = getTokenGroups().get(0).getFlatTokens();\n        return Collections.singletonList(parser.processExpression(singleLines, context));\n    }\n\n    @Override\n    public Token<Void> createToken(String value) {\n        return cloneDefaultProperties(new MultiLineToken());\n    }\n\n    @Override\n    public boolean isExpression() {\n        return true;\n    }\n}\n")),(0,a.yg)("p",null,"There are some subtle differences to this token:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Firstly we pass the ",(0,a.yg)("inlineCode",{parentName:"li"},"TokenType.SECONDARY")," in the constructor to make it clear this cannot be used on its own."),(0,a.yg)("li",{parentName:"ol"},"The grammar string expects the body to be wrapped in curly braces e.g. ",(0,a.yg)("inlineCode",{parentName:"li"},"{ ... }"),". We do something interesting\nhere in that we reference the singleLine token in a group that can occur one or more times. This might be a bit\nconfusing, but it saves having to repeat ourselves and just defer responsibility to the other class. As such, we'll\nhave the following references in some scenarios: OurIfToken => MultiLineToken => SingleLineToken."),(0,a.yg)("li",{parentName:"ol"},"We are only expecting one token group which will contain our SingleLineToken definitions. For this, we pass the\nlist of tokens to our parser and return the result."),(0,a.yg)("li",{parentName:"ol"},"Again we override the ",(0,a.yg)("inlineCode",{parentName:"li"},"isExpression")," method and return true.")),(0,a.yg)("p",null,"This might seem a bit confusing, but we don't need to cater to ",(0,a.yg)("inlineCode",{parentName:"p"},"else if")," scenarios as this is already covered. This\nis because ",(0,a.yg)("inlineCode",{parentName:"p"},"if (...) { ... } else ...")," covers that. The next ",(0,a.yg)("inlineCode",{parentName:"p"},"if")," statement will be a follow-on statement\nand executed as such. You can join as many if ... else if ... else if ... else ... statements as you like. This is\nsomething to keep in mind when designing your language."))}d.isMDXComponent=!0},3343:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/grammar-45d07a346c1d6b2311367db4ee94abf4.jpg"}}]);