"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[1555],{5680:(e,n,t)=>{t.d(n,{xA:()=>u,yg:()=>m});var r=t(6540);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=r.createContext({}),p=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(l.Provider,{value:n},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(t),d=o,m=c["".concat(l,".").concat(d)]||c[d]||g[d]||a;return t?r.createElement(m,i(i({ref:n},u),{},{components:t})):r.createElement(m,i({ref:n},u))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},667:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>g,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var r=t(8168),o=(t(6540),t(5680));const a={sidebar_position:10},i="Jumping",s={unversionedId:"toolkit/jumping",id:"toolkit/jumping",title:"Jumping",description:"Jumping",source:"@site/docs/toolkit/jumping.md",sourceDirName:"toolkit",slug:"/toolkit/jumping",permalink:"/docs/toolkit/jumping",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/toolkit/jumping.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Error Handling",permalink:"/docs/toolkit/error-handling"},next:{title:"Code Block Style",permalink:"/docs/toolkit/code-blocks"}},l={},p=[],u={toc:p},c="wrapper";function g(e){let{components:n,...a}=e;return(0,o.yg)(c,(0,r.A)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"jumping"},"Jumping"),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"Jumping",src:t(6748).A,width:"1950",height:"475"}),"\nJumping (think goto) is an old concept where you can skip to a certain point in the code identified by a label.\nThis was traditionally used in Assembly, Fortran, COBOL and C to name a few. There are several reasons why modern\nlanguages abandoned the concept:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},'Spaghetti Code: Using jumps or goto statements can lead to what is known as "spaghetti code," where the flow of the\nprogram becomes tangled and difficult to follow. This makes the code hard to read, maintain, and debug.'),(0,o.yg)("li",{parentName:"ul"},"Structured Programming: The rise of structured programming paradigms in the 1970s and 1980s emphasized the use of\ncontrol structures like loops (for, while) and conditionals (if, else) instead of jumps. This approach promotes clearer\nand more maintainable code."),(0,o.yg)("li",{parentName:"ul"},"Error-Prone: Jumps can easily lead to logical errors and bugs, especially in large and complex programs. They can\ncause unexpected behavior if not managed carefully."),(0,o.yg)("li",{parentName:"ul"},"Modern Alternatives: Modern programming languages provide more robust and safer alternatives to jumps, such as\nfunctions, methods, and exception handling mechanisms. These constructs help manage the flow of the program in a\nmore controlled and predictable manner."),(0,o.yg)("li",{parentName:"ul"},"Best Practices: Over time, best practices in software development have evolved to discourage the use of jumps. Code\nreadability, maintainability, and reliability are prioritized, and structured programming techniques are preferred.")),(0,o.yg)("p",null,"So, afer I've explained why languages no longer use them, why has jump support been added to LARF? This was originally\nadded for backwards compatibility purposes. Working on one of the examples during the development phase (",(0,o.yg)("a",{parentName:"p",href:"../examples/mal"},"My Assembly Language"),"),\nI found I was missing this feature and decided to implement it. Whether you choose to use it or not is your\nchoice, but so long as you are aware of why most modern languages have moved away from using them and are still\nhappy to use them, you are at liberty to do so. The following describes a short summary of how to add jumps to\nyour own language."),(0,o.yg)("h1",{id:"adding-jumps"},"Adding Jumps"),(0,o.yg)("p",null,"There are three steps to adding junps into your own language. In this example we will see how it was implemented in\nthe MAL example. This was done by creating a class called the LabelToken. This extends a class called JumpPointToken\nwhich is a special token picked up by the parser at runtime. The JumpPointToken has a method called ",(0,o.yg)("inlineCode",{parentName:"p"},"getLabel")," which\nallows the user to define a jump reference. Given this, if the ",(0,o.yg)("inlineCode",{parentName:"p"},"ParserFlags.JUMP")," is used and contains the reference\nto that label then the point of execution will skip straight to that point. Let's see what the LabelToken looks like:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},'public class LabelToken extends JumpPointToken<Void> {\n\n    public LabelToken() {\n        super("Label", null);\n    }\n\n    @Override\n    public Token<Void> createToken(String value) {\n        return cloneDefaultProperties(new LabelToken());\n    }\n\n    @Override\n    public PatternType getPatternType() {\n        return PatternType.GRAMMAR;\n    }\n\n    @Override\n    public String getPattern() {\n        return "val \':\'";\n    }\n\n    @Override\n    public Optional<String> getGuidance(String token, List<Integer> groupsCount) {\n        return Optional.empty();\n    }\n\n    @Override\n    protected List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n        return Collections.singletonList(config.getNullToken());\n    }\n\n    @Override\n    public String toString() {\n        return String.format("LabelToken{%s}", getTokenGroups().get(0).getFlatTokens().get(0).getValue(String.class));\n    }\n\n    @Override\n    public String getLabel() {\n        return getTokenGroups().get(0).getFlatTokens().get(0).getValue(String.class);\n    }\n}\n')),(0,o.yg)("p",null,"As can be seen, we're defining the label in the ",(0,o.yg)("inlineCode",{parentName:"p"},"getLabel")," method as the value that being captured. The next point\nis to look at the token which triggers the jump. In MAL's case we needed to define a JLE command where a jump is\ntriggered if the CMP operation resulted in the first argument being less or equal to the second. Let's see how that\nis defined:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},'public class JleToken extends JumpToken<Void> {\n\n    //...\n\n    @Override\n    protected List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n        Object found = context.getContextObject("cmpResult");\n        clearParserFlags();\n        if (Objects.isNull(found)) {\n            throw new ParserException("Expected cmp result to be present but none found. Please use \'cmp\' " +\n                    "prior to calling jle!");\n        }\n        if (found instanceof IntegerToken) {\n            if (((IntegerToken)found).getValue() <= 0) {\n                addParserFlag(ParserFlag.JUMP);\n            }\n        } else {\n            throw new ParserException("Expected cmp result to be in Integer format. Instead found" +\n                    found.getClass().getSimpleName());\n        }\n        return Collections.singletonList(this);\n    }\n\n    @Override\n    public String getLabel() {\n        return getTokenGroups().get(0).getFlatTokens().get(0).getValue(String.class);\n    }\n\n    //...\n}\n')),(0,o.yg)("p",null,"In the above case I've only shown the pertinent methods relevant to the jump operation. As we can see we're first\nfetching the cmpResult which is the value set to context from our CmpToken. Next we clear any pre-existing parser\nflags against our token. This is good practise, but in our case it's necessary as in our example we're in a loop.\nLet's look at the assembly language section of the example in question:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"; loop from 1 to 5\nloop:\n    ADD [sum], [counter] ; add counter to sum\n    inc byte [counter]   ; increment counter\n    cmp [counter], 5     ; compare counter with 5\n    jle loop             ; if counter <= 5, jump to loop\n")),(0,o.yg)("p",null,"As can be seen, we've defined our jump point label (",(0,o.yg)("inlineCode",{parentName:"p"},"loop:"),") and the last two lines are the ",(0,o.yg)("inlineCode",{parentName:"p"},"cmp")," which\ncompares the counter against the value ",(0,o.yg)("inlineCode",{parentName:"p"},"5"),". If found that the comparison is <= 5 then we jump to back to\nthe ",(0,o.yg)("inlineCode",{parentName:"p"},"loop")," label. On the next line of the JleToken ",(0,o.yg)("inlineCode",{parentName:"p"},"process")," method, we determine whether we need to\ntrigger the jump by looking at the result of the ",(0,o.yg)("inlineCode",{parentName:"p"},"Integer.compareTo"),". If it's less than 0 then we set the\n",(0,o.yg)("inlineCode",{parentName:"p"},"ParserFlag.JUMP")," to the current token and return as normal."),(0,o.yg)("p",null,"Finally we need to configure our language to use Jumps. We can do this from our configuration object:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},"public class MALConfig extends LARFConfig {\n\n    public MALConfig(String languageId, double languageVersion) {\n        super(languageId, languageVersion);\n        initProperties();\n    }\n\n    protected MALConfig(String languageId, double languageVersion, String authorName, List<String> authorContact) {\n        super(languageId, languageVersion, authorName, authorContact);\n        initProperties();\n    }\n\n    private void initProperties() {\n        setProperty(DefaultProperty.JUMP_SUPPORT, true);\n        setProperty(DefaultProperty.FORWARD_JUMPING, true);\n        setProperty(DefaultProperty.GLOBAL_SCOPE, true);\n        setProperty(DefaultProperty.CASE_SENSITIVE, false);\n    }\n\n    //...\n}\n")),(0,o.yg)("p",null,"There are actually two properties here related to jumping. The first is to enable jump support by setting the\n",(0,o.yg)("inlineCode",{parentName:"p"},"DefaultProperty.JUMP_SUPPORT")," to true. The default behaviour of jumps is to only junp backwards of the current\npoint of execution. The second optional (",(0,o.yg)("inlineCode",{parentName:"p"},"DefaultProperty.FORWARD_JUMPING"),") flag allows execution to skip to\na point both behind and in front of the current line."))}g.isMDXComponent=!0},6748:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/jumping-84daebb3e5f83f7def13f962fcfcf79b.jpg"}}]);