"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[464],{5680:(e,r,t)=>{t.d(r,{xA:()=>d,yg:()=>m});var n=t(6540);function a(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function o(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?o(Object(t),!0).forEach((function(r){a(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function s(e,r){if(null==e)return{};var t,n,a=function(e,r){if(null==e)return{};var t,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],r.indexOf(t)>=0||(a[t]=e[t]);return a}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=n.createContext({}),l=function(e){var r=n.useContext(p),t=r;return e&&(t="function"==typeof e?e(r):i(i({},r),e)),t},d=function(e){var r=l(e.components);return n.createElement(p.Provider,{value:r},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},h=n.forwardRef((function(e,r){var t=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(t),h=a,m=u["".concat(p,".").concat(h)]||u[h]||c[h]||o;return t?n.createElement(m,i(i({ref:r},d),{},{components:t})):n.createElement(m,i({ref:r},d))}));function m(e,r){var t=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=h;var s={};for(var p in r)hasOwnProperty.call(r,p)&&(s[p]=r[p]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=t[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}h.displayName="MDXCreateElement"},6942:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var n=t(8168),a=(t(6540),t(5680));const o={sidebar_position:4},i="Modus operandi",s={unversionedId:"tutorial/modus-operandi",id:"tutorial/modus-operandi",title:"Modus operandi",description:"As with everything we need to tell LARF how to handle operators. This would be the same if we're teaching a",source:"@site/docs/tutorial/modus-operandi.mdx",sourceDirName:"tutorial",slug:"/tutorial/modus-operandi",permalink:"/docs/tutorial/modus-operandi",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial/modus-operandi.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Speaking literally",permalink:"/docs/tutorial/speaking-literally"},next:{title:"Type Operations",permalink:"/docs/tutorial/type-operations"}},p={},l=[{value:"Operator Types",id:"operator-types",level:3},{value:"Arithmetic Operator Handler",id:"arithmetic-operator-handler",level:3},{value:"Configure and... seriously?",id:"configure-and-seriously",level:3}],d={toc:l},u="wrapper";function c(e){let{components:r,...t}=e;return(0,a.yg)(u,(0,n.A)({},d,t,{components:r,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"modus-operandi"},"Modus operandi"),(0,a.yg)("p",null,"As with everything we need to tell LARF how to handle operators. This would be the same if we're teaching a\nchild how to count. First you start with basic numbers and increments. Once they've grasped that they can then move\nonto addition, subtraction, multiplication and division etc. In our case and for this to work, we first need to define\na set of arithmetic operators."),(0,a.yg)("h3",{id:"operator-types"},"Operator Types"),(0,a.yg)("p",null,"In programming there are multiple sets of operators, each with a different purpose. Within LARF there are several\npre-defined template classes you can use for most cases. These are:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"ArithmeticOperator"),(0,a.yg)("li",{parentName:"ul"},"AssignmentOperator"),(0,a.yg)("li",{parentName:"ul"},"BitwiseOperator"),(0,a.yg)("li",{parentName:"ul"},"ComparisonOperator"),(0,a.yg)("li",{parentName:"ul"},"LogicOperator")),(0,a.yg)("admonition",{title:"Custom Operator Types",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"You are not limited to just these should you want to define your own sets of operators. You can create a new class\nextending OperatorHandler and pass it the operator types defined in an enum which you pass as a generic e.g.\n",(0,a.yg)("inlineCode",{parentName:"p"},"class MyCustomOperators extends OperatorHandler<MyCustomOperatorsType> { .. }"),". This can either be an abstract\ntemplate or concrete implementation. You can also override the order in which sets of operators are called. You can do\nthis by overriding the ",(0,a.yg)("inlineCode",{parentName:"p"},"OperatorHandler.getHandlerOrder")," method. The lower a value the higher priority those are given\nduring execution. In any case, the default sets should cover the requirements of the majority of languages.")),(0,a.yg)("h3",{id:"arithmetic-operator-handler"},"Arithmetic Operator Handler"),(0,a.yg)("p",null,"Let's start out with defining an arithmetic operator set so we can do some basic calculations. To do this, let's create\na new package within the tokens package called operators:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"...\n[src]\n   [main]\n       [java]\n           [com.aardvark]\n               [config]\n                   AardvarkConfig.java\n               [tokens]\n                   [operators]\n                       AardvarkArithmeticOperator.java\n                   [literals]                       \n                       IntegerToken.java\n                       NullToken.java\n               Application.java\n...\n")),(0,a.yg)("p",null,"Next we'll extend from the ArithmeticOperator class and inherit the methods:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'public class AardvarkArithmeticOperator extends ArithmeticOperator {\n\n    public AardvarkArithmeticOperator(String value) {\n        super(value);\n    }\n\n    @Override\n    protected void initOperators() {\n        addOperator("+", ArithmeticOperatorType.ADD);\n        addOperator("-", ArithmeticOperatorType.SUBTRACT);\n        addOperator("/", ArithmeticOperatorType.DIVIDE);\n        addOperator("*", ArithmeticOperatorType.MULTIPLY);\n        addOperator("%", ArithmeticOperatorType.MODULO);\n    }\n\n    @Override\n    public String getPattern() {\n        return "^(\\\\+|-|\\\\/|\\\\*|%)";\n    }\n\n    @Override\n    public Token<String> createToken(String value) {\n        return new AardvarkArithmeticOperator(value);\n    }\n\n    @Override\n    public String[][] getOperatorOrder() {\n        return new String[][] {\n                {"/", "*", "%"},\n                {"+", "-"}\n        };\n    }\n}\n')),(0,a.yg)("p",null,"There are three key methods in this class. The first is a new one called initOperators. This allows us to associate a\nString value to one of the Arithmetic operator types. To keep things familiar, I'm using the standard C / Java notation,\nbut feel free to define your own preferred operator values."),(0,a.yg)("p",null,"Following on from this we have the typical Token.getPattern method. This contains the pattern of the operators defined\nin the initOperators method*. The final method determines the order in which operators are executed for a given operator\ntype. In our case we will follow BODMAS which determines that multiplication / division come before addition /\nsubtraction. A 2-dimensional array is defined with the operators of higher priority placed higher up."),(0,a.yg)("h3",{id:"configure-and-seriously"},"Configure and... seriously?"),(0,a.yg)("p",null,"As with all other tokens, we need to add it into our config class:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"@Override\npublic class AardvarkConfig extends LARFConfig {\n    //...\n    @Override\n    protected void initOperators() {\n        addOperatorHandler(new AardvarkArithmeticOperator(null));\n    }\n    //...\n}\n")),(0,a.yg)("admonition",{title:"Declaration Order",type:"danger"},(0,a.yg)("p",{parentName:"admonition"},"Please ensure the order of your operators does not conflict. For example, if you define ADD and INCREMENT operators,\nbut the ADD precedes the latter, the increment will never be matched. This is because it will always go with the first\nmatch found and set that as the operator value. As such, to prevent this we put the '++' in front of the '+' to ensure\nwe match the correct type e.g. ",(0,a.yg)("inlineCode",{parentName:"p"},"^(...|\\\\+\\\\+|\\\\+|...)")," rather than ",(0,a.yg)("inlineCode",{parentName:"p"},"^(...|\\\\+|\\\\+\\\\+|...)"),".")),(0,a.yg)("p",null,"Let's load up our runner and now see what happens:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"10 + 10\ndev.larf.exception.ParserException: No handler for type operation with arguments of type IntegerToken and IntegerToken found.\n    at dev.larf.parser.LARFParser.processOp(LARFParser.java:317)\n    at dev.larf.parser.LARFParser.processExpression(LARFParser.java:113)\n    at dev.larf.parser.LARFParser.process(LARFParser.java:44)\n    at dev.larf.processor.LARFProcessor.process(LARFProcessor.java:83)\n    at dev.larf.runner.LARFRunner.run(LARFRunner.java:39)\n    at dev.larf.runner.LARFRunner.run(LARFRunner.java:10)\n    at dev.larf.languages.aardvark.AardvarkRunner.main(AardvarkRunner.java:11)\n")),(0,a.yg)("p",null,"Although we've defined our operators, LARF still doesn't know what it is supposed to do with it during parsing. This\nis where we define type operations. These not only tell it what to do in the situation of an operator occurring,\nbut is also specific to given types. For example, you can add two Integers together using ",(0,a.yg)("inlineCode",{parentName:"p"},"1 + 1")," in Java, but you\ncan't do ",(0,a.yg)("inlineCode",{parentName:"p"},"[1,2] + [3,4]"),". By defining a type operation for an array type and configuring it to handle\n",(0,a.yg)("inlineCode",{parentName:"p"},"ArithmeticOperatorType.ADD"),", we can provide this easily. More on that later, but for now join us in the next section\nwhere we define a new type operation."))}c.isMDXComponent=!0}}]);