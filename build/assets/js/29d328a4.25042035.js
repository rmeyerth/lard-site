"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[6986],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>h});var o=n(6540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},g="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),g=c(n),d=a,h=g["".concat(s,".").concat(d)]||g[d]||u[d]||r;return n?o.createElement(h,l(l({ref:t},p),{},{components:n})):o.createElement(h,l({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[g]="string"==typeof e?e:a,l[1]=i;for(var c=2;c<r;c++)l[c]=n[c];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9690:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var o=n(8168),a=(n(6540),n(5680));const r={sidebar_position:3},l="Callbacks",i={unversionedId:"toolkit/tokens/callbacks",id:"toolkit/tokens/callbacks",title:"Callbacks",description:"Callbacks",source:"@site/docs/toolkit/tokens/callbacks.md",sourceDirName:"toolkit/tokens",slug:"/toolkit/tokens/callbacks",permalink:"/docs/toolkit/tokens/callbacks",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/toolkit/tokens/callbacks.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"References",permalink:"/docs/toolkit/tokens/references"},next:{title:"Grammar",permalink:"/docs/toolkit/tokens/grammar"}},s={},c=[],p={toc:c},g="wrapper";function u(e){let{components:t,...r}=e;return(0,a.yg)(g,(0,o.A)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"callbacks"},"Callbacks"),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"Callbacks",src:n(6887).A,width:"1465",height:"325"}),"\nA token callback is used when two tokens must work together in order to achieve a goal. Let's take the ",(0,a.yg)("inlineCode",{parentName:"p"},"for"),"\nloop example where we defer the loop and body portions to other token classes. For example, here is the pattern\nfor a ForToken:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"@Override\npublic String getPattern() {\n    return \"'for' '(' [ fixedLoop, variableLoop ] ')' [ singleLine, multiLine ]\";\n}\n")),(0,a.yg)("p",null,"You'll notice that we have two grammar references which defer execution to different tokens for both the loop\nand body portion. Let's now take a look in the ",(0,a.yg)("inlineCode",{parentName:"p"},"process")," method of the ForToken class:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'@Override\npublic List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n    if (getTokenGroups().size() != 2) {\n        String foundTokens = getTokenGroups().stream()\n                .flatMap(tg -> tg.getFlatTokens().stream())\n                .map(t -> t.getClass().getSimpleName())\n                .collect(Collectors.joining(", "));\n        throw new ParserException("For token expects two tokens being the looping portion and the body. " + \n                "Instead got " + foundTokens);\n    }\n    Token<?> loopToken = getTokenGroups().get(0).getFlatTokens().get(0);\n    Token<?> bodyToken = getTokenGroups().get(1).getFlatTokens().get(0);\n    return loopToken.processWithCallback(parser, context, config, () -> {\n        List<Token<?>> result = bodyToken.processNoParams(parser, context, config);\n        if (result.size() == 1 && result.get(0) instanceof ReturnToken) {\n            return Optional.of(result.get(0));\n        }\n        return Optional.empty();\n    });\n}\n')),(0,a.yg)("p",null,"In the first portion we are just validating that we are expecting two token groups. The first representing the\nloop token reference with the second being the body. Next we simply assign these to suitably named token variables.\nThe next portion sees us call ",(0,a.yg)("inlineCode",{parentName:"p"},"loopToken.processWithCallback")," which accepts a lambda call. Let's now\ntake a look at the VariableLoopToken to see when this lambda is being used:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'public class VariableLoopToken extends Token<Void> implements TokenCallback {\n    \n    //...\n    \n    @Override\n    public List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config, ReferenceCallback callback) {\n        List<Token<?>> arrayResult = new ArrayList<>();\n        if (getTokenGroups().size() < 2) {\n            throw new ParserException("Expected a variable and a collection provided in the for each " + \n                    "iterator statement");\n        }\n        Token<?> varArg = getTokenGroups().get(0).getFlatTokens().get(0);\n        //Resolve the variable name to be used to store the iterated object in context\n        String variableName = (varArg instanceof TokenGroup) ?\n                ((TokenGroup)varArg).getFlatTokens().get(0).getValue(String.class) :\n                varArg.getValue(String.class);\n        List<Token<?>> collectionArgs = getTokenGroups().get(1).getFlatTokens();\n        Collection<?> collection;\n        //Resolve the collection object\n        if (collectionArgs.size() == 1 && collectionArgs.get(0) instanceof TokenValue) {\n            String collectionRef = collectionArgs.get(0).getValue(String.class);\n            Object suspectedCollection = context.getContextObject(collectionRef);\n            if (!(suspectedCollection instanceof Collection)) {\n                throw new ParserException(String.format("The reference used in the for each loop (%s) " + \n                        "did not result in a collection. Instead found \'%s\'", collectionRef, \n                            suspectedCollection.getClass().getSimpleName()));\n            }\n            collection = (Collection<?>)suspectedCollection;\n        } else {\n            collection = parser.processExpression(collectionArgs, context).getValue(Collection.class);\n        }\n        for (Object current : collection) {\n            //Set the current object to the defined variable\n            context.set(variableName, current);\n            Optional<Token<?>> result = callback.call();\n            if (result.isPresent()) {\n                if (result.get().getParserFlags().contains(ParserFlag.RETURN_GROUP)) {\n                    arrayResult.add((Token<?>) result.get().getValue());\n                } else if (result.get().getParserFlags().contains(ParserFlag.RETURN)) {\n                    return Collections.singletonList((Token<?>) result.get().getValue());\n                }\n            }\n        }\n        return Collections.singletonList(new ArrayToken(arrayResult));\n    }\n}\n')),(0,a.yg)("p",null,"First you'll notice that the VariableLoopToken (just like the equivalent FixedLoopToken) implements the TokenCallback\ninterface. This requires us to implement the process method with the extra ReferenceCallback parameter. Looking at the\nimplementation of the code this look complicated, but let's break it down and see where that ",(0,a.yg)("inlineCode",{parentName:"p"},"ReferenceCallback")," is used."),(0,a.yg)("p",null,"First we ensure that we have the valid number of arguments otherwise an error is thrown. We next extract the\nvariable name portion of the loop e.g. ",(0,a.yg)("inlineCode",{parentName:"p"},"for (emp : employees)")," and assign it to a ",(0,a.yg)("inlineCode",{parentName:"p"},"variableName")," String\nvariable. Next we use the value found in the second token group and retrieve the suspected collection from context\nand assign it to the ",(0,a.yg)("inlineCode",{parentName:"p"},"collection")," variable. Following this, we simply do a for loop on the collection,\nset the current object into context using the variable name and then call ",(0,a.yg)("inlineCode",{parentName:"p"},"Optional<Token<?>> result = callback.call();"),".\nIn simply term, for each iteration that occurs in our loop call the callback lambda. Let's return to the\nForToken again and look more closely at the lambda call:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"return loopToken.processWithCallback(parser, context, config, () -> {\n    List<Token<?>> result = bodyToken.processNoParams(parser, context, config);\n    if (result.size() == 1 && result.get(0) instanceof ReturnToken) {\n        return Optional.of(result.get(0));\n    }\n    return Optional.empty();\n});\n")),(0,a.yg)("p",null,"So for each iteration, we are calling the ",(0,a.yg)("inlineCode",{parentName:"p"},"bodyToken.processNoParams")," method. If the body token returns a\nReturnToken (token to return a value instantly), then we return that token or else we return an empty Optional.\nLet's now look back at the remaining code in the VariableLoopToken after the callback call:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"//...\nOptional<Token<?>> result = callback.call();\nif (result.isPresent()) {\n    if (result.get().getParserFlags().contains(ParserFlag.RETURN_GROUP)) {\n        arrayResult.add((Token<?>) result.get().getValue());\n    } else if (result.get().getParserFlags().contains(ParserFlag.RETURN)) {\n        return Collections.singletonList((Token<?>) result.get().getValue());\n    }\n}\n")),(0,a.yg)("p",null,"If the result from the body contains a RETURN_GROUP parser flag then we add it to the list of results and continue.\nAlternatively if we come across the ParserFlat.RETURN parser flag then we return immediately and break out of the\nremaining loop iterations. If you'd like to learn more about parser flags and how they are used, please see\n",(0,a.yg)("a",{parentName:"p",href:"/docs/toolkit/parser/parser-flags"},"Parser Flags"),"."),(0,a.yg)("p",null,"If it's not clear what is happening from the code, let's use a step list to show when each token gets called:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"ForToken"),": Calls VariableLoopToken using ",(0,a.yg)("inlineCode",{parentName:"li"},"processWithCallback"),"."),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"VariableLoopToken"),": Resolves the name and collection into variables. Loops through each object in the collection\nand sets the current object to a variable using the name ref in context. A call is then made to the lambda method reference."),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"ForToken"),": The lambda we defined in the ",(0,a.yg)("inlineCode",{parentName:"li"},"processWithCallback")," is called. This makes a call to the body token"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"SingleLineToken")," / ",(0,a.yg)("strong",{parentName:"li"},"MultiLineToken"),": Dependent on how the body was defined, it will execute the code found within\nand return a result in the form of a token back to the lambda in the ForToken."),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"ForToken"),": Once a result has been received from the body, it is checked to see if a valid token result has been\nreceived and if so is returned in an Optional."),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"VariableLoopToken"),": The token result from the callback is read and if it contains a RETURN* parser flag is\nhandled accordingly."),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"ForToken"),": Once all iterations of the loop have completed or have been terminated prematurely due to a parser\nflag, the result is then returned.")),(0,a.yg)("p",null,"The ForToken then sits in the middle and determines what will happen when the callback occurs. In this case a callback\nwill occur after each loop iteration. At which point the ForLoop in the lambda calls the body token to execute. Once\nfinished it will then return control back to the Looping token to either continue the loop or exit dependant on the result\nfrom the body."))}u.isMDXComponent=!0},6887:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/callback-fcfbde22ed9c58589542e476aca746fa.jpg"}}]);