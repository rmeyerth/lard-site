"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[6029],{5680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>m});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(t),g=a,m=u["".concat(l,".").concat(g)]||u[g]||d[g]||o;return t?r.createElement(m,i(i({ref:n},p),{},{components:t})):r.createElement(m,i({ref:n},p))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=g;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},9906:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=t(8168),a=(t(6540),t(5680));const o={sidebar_position:6},i="Point of decimals",s={unversionedId:"tutorial/point-of-decimals",id:"tutorial/point-of-decimals",title:"Point of decimals",description:"Decimal Token",source:"@site/docs/tutorial/point-of-decimals.md",sourceDirName:"tutorial",slug:"/tutorial/point-of-decimals",permalink:"/docs/tutorial/point-of-decimals",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial/point-of-decimals.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Type Operations",permalink:"/docs/tutorial/type-operations"},next:{title:"Making a statement",permalink:"/docs/tutorial/make-a-statement"}},l={},c=[{value:"Decimal Token",id:"decimal-token",level:3},{value:"Token Localisation",id:"token-localisation",level:3},{value:"Changes to the Type Operation Class",id:"changes-to-the-type-operation-class",level:3},{value:"Making our Type Operation more Generic",id:"making-our-type-operation-more-generic",level:3}],p={toc:c},u="wrapper";function d(e){let{components:n,...t}=e;return(0,a.yg)(u,(0,r.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"point-of-decimals"},"Point of decimals"),(0,a.yg)("h3",{id:"decimal-token"},"Decimal Token"),(0,a.yg)("p",null,"Decimals will be our second literal type that we'll add to our language. To do this let's start by creating a\nnew DecimalToken.java class in the ",(0,a.yg)("inlineCode",{parentName:"p"},"tokens.literals")," package. This will be defined as the following:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'public class DecimalToken extends Token<Double> {\n\n    public DecimalToken() { super("Double", 0.0); }\n\n    public DecimalToken(Double value) {\n        super("Double", value);\n    }\n\n    @Override\n    public PatternType getPatternType() {\n        return PatternType.REGEX;\n    }\n\n    @Override\n    public String getPattern() {\n        return "^-?[0-9]+\\\\.[0-9]+";\n    }\n\n    @Override\n    public Optional<String> getGuidance(String token, List<Integer> groupsCount) {\n        return Optional.empty();\n    }\n\n    @Override\n    public List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n        return Collections.singletonList(this);\n    }\n\n    @Override\n    public Token<Double> createToken(String value) {\n        return new DecimalToken(Double.parseDouble(value));\n    }\n}\n')),(0,a.yg)("p",null,"The pattern is really the only thing is note here. Again we're defining an optional '-' character preceding the number,\nfollowed by one or more numbers from 0 to 9 separated by a '.'. "),(0,a.yg)("h3",{id:"token-localisation"},"Token Localisation"),(0,a.yg)("p",null,"We could actually choose to make our language adhere to the rules of the country it is running in. For example, we\ncould use the following:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'public class DecimalToken extends Token<Double> {\n    //...\n    @Override\n    public String getPattern() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getNumberInstance(Locale.getDefault());\n        String n = df.format(1.1);\n        return String.format("^-?[0-9]+\\\\%s[0-9]+", n.charAt(1));\n    }\n    //...\n}\n')),(0,a.yg)("admonition",{title:"Customisation",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"LARF is completely customisable and most classes designed to be extensible or have their methods overridden. If you\ndon't like the default behaviour, change it and do something crazy!")),(0,a.yg)("p",null,"For Aardvark, I'll omit any localisation to keep things simple. Let's add our new token to the config:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class AardvarkConfig extends LARFConfig {\n    //...\n    @Override\n    protected void initTokenHandlers() {\n        addTokenHandler(new NullToken());\n        addTokenHandler(new DecimalToken());        \n        //As both decimal and integers use number regular expressions, avoid issues by placing Decimal before Integers\n        addTokenHandler(new IntegerToken());\n    }\n    //...\n}\n")),(0,a.yg)("h3",{id:"changes-to-the-type-operation-class"},"Changes to the Type Operation Class"),(0,a.yg)("p",null,"Now let's go back to our IntegerOperation class. The natural behaviour of Java as well as other languages is to stick\nto the types being used in the operation. As such, when we do ",(0,a.yg)("inlineCode",{parentName:"p"},"Integer <divide> Integer"),", we get back an Integer even\nif we wanted to keep precision. One solution to this to use a type that can handle both number formats and then cast\nthe result to the desired type. Let's look back at the ",(0,a.yg)("inlineCode",{parentName:"p"},"IntegerOperation.process")," method:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class IntegerOperation implements TypeOperation {\n    //...\n    @Override\n    public Token<?> process(LARFConfig config, LARFContext context, Token<?> firstToken, OperatorHandler<?> operator,\n                            Token<?> secondToken, Token<?> leftSide) {\n      //Extract token values to BigDecimal\n      BigDecimal first = new BigDecimal(firstToken.getValue(Integer.class));\n      BigDecimal second = new BigDecimal(secondToken.getValue(Integer.class));\n      //Check that operator is Arithmetic and handle each case using switch\n      if (operator instanceof ArithmeticOperator) {\n        switch (((ArithmeticOperator)operator).getOpType()) {\n          case ADD: return wrap(first.add(second));\n          case SUBTRACT: return wrap(first.subtract(second));\n          case DIVIDE: return wrap(first.divide(second, 6, RoundingMode.HALF_UP));\n          case MULTIPLY: return wrap(first.multiply(second));\n          case MODULO: return wrap(first.remainder(second));\n        }\n      }\n      //Fallback\n      return handleCustomOperator(firstToken, operator, secondToken);\n    }\n\n    private Token<?> wrap(BigDecimal result) {\n        return result.stripTrailingZeros().scale() >= 0 ?\n            new DecimalToken(result.doubleValue()) :\n            new IntegerToken(result.intValue());\n    }\n}\n")),(0,a.yg)("p",null,"The following changes have made the code a lot more capable at the cost of some complexity. Firstly both Integer values\nare cast to BigDecimal. This presumes that all operations have the possibility to spit out a remainder value. We've also\nchanged the behaviour of our wrap method to check if the result has a remainder and return the appropriate type.\nLet's try our runner again:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"-10 / 3\nResult: -3.333333 (Type: Double, Time taken: 11ms)\n3 * 10\nResult: 30 (Type: Integer, Time taken: 1ms)\n6 / 4\nResult: 1.5 (Type: Double, Time taken: 1ms)\n5 + 3 / 2\ndev.larf.exception.ParserException: No handler for type operation with arguments of type IntegerToken and DecimalToken found.\n    at dev.larf.parser.LARFParser.processOp(LARFParser.java:317)\n    at dev.larf.parser.LARFParser.replaceCalcsInfix(LARFParser.java:382)\n    at dev.larf.parser.LARFParser.lambda$processExpression$0(LARFParser.java:74)\n    at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)\n    at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:658)\n    at dev.larf.parser.LARFParser.lambda$processExpression$1(LARFParser.java:74)\n    at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)\n    at java.base/java.util.stream.SortedOps$SizedRefSortingSink.end(SortedOps.java:357)\n    ...\n")),(0,a.yg)("h3",{id:"making-our-type-operation-more-generic"},"Making our Type Operation more Generic"),(0,a.yg)("p",null,"This is where things turn a bit interesting. Firstly, we can now see that it is casting to either a Double or Integer\ndepending on the calculation. However, we get an error when try something a bit more complex. This is because the\nresult of ",(0,a.yg)("inlineCode",{parentName:"p"},"3 / 2")," is 1.5. The next parser operation (given our use of BODMAS) will be 5 + 1.5 which we don't yet\nsupport. Don't worry, I'm not going to recommend creating an operation class for every possible type pairing as we can\nmake life easier for ourselves. Firstly, I'm going to rename IntegerOperation to NumericOperation:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class NumericOperation implements TypeOperation {\n\n    @Override\n    public boolean canHandle(Token<?> first, OperatorHandler<?> operator, Token<?> second) {\n        try {\n            if (Objects.isNull(first.getValue()) || Objects.isNull(second.getValue())) return false;\n            new BigDecimal(first.getValue().toString());\n            new BigDecimal(second.getValue().toString());\n            return true;\n        } catch (NumberFormatException ex) {\n            return false;\n        }\n    }    \n    //...\n}\n")),(0,a.yg)("p",null,"Secondly I've modified the operations canHandle method. The BigDecimal class is quite adept at handling any number of\ndifferent types, so it useful as a handler in this scenario. If whatever the token value is can be parsed then it means\nwe can handle it, otherwise we'll return false and defer to other operation classes."),(0,a.yg)("p",null,"Let's load up our runner once more:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"-10 / 3\nResult: -3.333333 (Type: Double, Time taken: 11ms)\n3 * 10\nResult: 30 (Type: Integer, Time taken: 1ms)\n6 / 4\nResult: 1.5 (Type: Double, Time taken: 1ms)\n5 + 3 / 2\nResult: 6.5 (Type: Double, Time taken: 4ms)\n")),(0,a.yg)("p",null,"Perfect! What happens though if we want to resolve 5 + 3 before dividing by 2? Well, this would be achieved using\nparentheses and will be the perfect introduction to statements. It will also be our first introduction to defining a\ntoken using grammar as opposed to regular expressions."),(0,a.yg)("p",null,"Up until now, the tokens we've created have all represented types. Null, Decimal, Integer etc. Now we're\ngoing to define one whose sole purpose is to perform a task based on one or more tokens, or more accurately groups of\ntokens, passed to it by the lexer. These groups are defined in the token's grammar. Don't worry if this all sounds\npretty confusing, as it will become more explanatory by showing you in the next section."))}d.isMDXComponent=!0}}]);