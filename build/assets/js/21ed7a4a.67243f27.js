"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[730],{5680:(e,r,n)=>{n.d(r,{xA:()=>d,yg:()=>h});var t=n(6540);function a(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function o(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),n.push.apply(n,t)}return n}function i(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?o(Object(n),!0).forEach((function(r){a(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}))}return e}function s(e,r){if(null==e)return{};var n,t,a=function(e,r){if(null==e)return{};var n,t,a={},o=Object.keys(e);for(t=0;t<o.length;t++)n=o[t],r.indexOf(n)>=0||(a[n]=e[n]);return a}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)n=o[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=t.createContext({}),c=function(e){var r=t.useContext(l),n=r;return e&&(n="function"==typeof e?e(r):i(i({},r),e)),n},d=function(e){var r=c(e.components);return t.createElement(l.Provider,{value:r},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var r=e.children;return t.createElement(t.Fragment,{},r)}},g=t.forwardRef((function(e,r){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),g=a,h=p["".concat(l,".").concat(g)]||p[g]||u[g]||o;return n?t.createElement(h,i(i({ref:r},d),{},{components:n})):t.createElement(h,i({ref:r},d))}));function h(e,r){var n=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=g;var s={};for(var l in r)hasOwnProperty.call(r,l)&&(s[l]=r[l]);s.originalType=e,s[p]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return t.createElement.apply(null,i)}return t.createElement.apply(null,n)}g.displayName="MDXCreateElement"},2379:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var t=n(8168),a=(n(6540),n(5680));const o={sidebar_position:10},i="Error Handling",s={unversionedId:"toolkit/error-handling",id:"toolkit/error-handling",title:"Error Handling",description:"Error Handling",source:"@site/docs/toolkit/error-handling.md",sourceDirName:"toolkit",slug:"/toolkit/error-handling",permalink:"/docs/toolkit/error-handling",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/toolkit/error-handling.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Typed / Typeless",permalink:"/docs/toolkit/typed-typeless"},next:{title:"Jumping",permalink:"/docs/toolkit/jumping"}},l={},c=[{value:"Native Errors",id:"native-errors",level:3},{value:"Custom Errors",id:"custom-errors",level:3}],d={toc:c},p="wrapper";function u(e){let{components:r,...o}=e;return(0,a.yg)(p,(0,t.A)({},d,o,{components:r,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"error-handling"},"Error Handling"),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"Error Handling",src:n(6214).A,width:"1642",height:"427"})),(0,a.yg)("admonition",{title:"Example Source",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"For this section, I am going to use the SLOP language implementation to show how errors are handled. You can\ncheck out the full SLOP source code and its error handling code ",(0,a.yg)("a",{parentName:"p",href:"https://www.gitlab.com/tronied/slop"},"here"),".")),(0,a.yg)("p",null,"Handling errors is a maintstay of any language. This allows developers not just the ability to throw and handle\ntheir own errors, but also provide traceability as to where the issue occurred and how to resolve it. The majority\nof languages have two basic types of error, known as exceptions in Java, that can be thrown. The first of these is\na checked error which requires it to be declared or handled by methods / resources moving up the call hierarchy.\nThe second (unchecked) means no declaration needs to take place, but hides which errors may be thrown in the body\nof code being executed. This section will look at how we would implement not just these types of error,\nbut also how we can handle and throw our own types of error in a language we create."),(0,a.yg)("h3",{id:"native-errors"},"Native Errors"),(0,a.yg)("p",null,"Before we move onto defining custom errors, types and handling them, it is worth addressing that LARF has the\nability to catch and interpret native errors and propagate them as errors into your language. This may sound\nconfusing as to why you'd want to do this, but let's take a look at the following:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"func aMethod(a) {\n    //Will throw a divide by 0 error\n    return a / 0;\n}\n\nreturn aMethod(4);\n")),(0,a.yg)("p",null,"We could in fact write a bunch of custom errors to handle these scenarios in our type operation classes, but\nsince these errors are already being thrown by the underlying language (Java), why not use them? To do this\nwe can extend one of the following classes found within LARF:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"StandardErrorHandler"),(0,a.yg)("li",{parentName:"ul"},"ResourceErrorHandler"),(0,a.yg)("li",{parentName:"ul"},"NetworkErrorHandler"),(0,a.yg)("li",{parentName:"ul"},"ThreadErrorHandler"),(0,a.yg)("li",{parentName:"ul"},"TypeErrorHandler\nEach of these has a set of native error mappings. For example, if we wanted to handle the above scenario within\nour langauge, we could write the following class:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'public class SLOPStandardErrorHandler extends StandardErrorHandler {\n\n    public SLOPStandardErrorHandler(String name) {\n        super(name);\n    }\n\n    @Override\n    public void initErrorHandlers() {\n        addErrorMapping("ArithmeticError", StandardError.ARITHMETIC);\n    }\n}\n')),(0,a.yg)("p",null,"Here we are assigning a specific language name to the arithmetic error type which would be thrown in the case of\na division by 0. These error handler mappings can be registered in the configuration class under the ",(0,a.yg)("inlineCode",{parentName:"p"},"initErrorHandler"),"\nmethod:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"@Override\nprotected void initErrorHandlers() {\n    addErrorHandler(new SLOPStandardErrorHandler(null));\n}\n")),(0,a.yg)("p",null,"Now, if we run the above code we will find we get the following error thrown in our language:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"Unhandled ArithmeticError: / by zero (Mapped JVM Error)\n=======================================================\nOperation: 4 / 0\nSLOP Trace:\n  at Default.aMethod(Expression:3)\n  at Default.None(Expression:6)\nJVM Trace:\n  at java.math.BigDecimal.divideAndRound(BigDecimal.java:4955)\n  at java.math.BigDecimal.divide(BigDecimal.java:6028)\n  at java.math.BigDecimal.divide(BigDecimal.java:1653)\n  at java.math.BigDecimal.divide(BigDecimal.java:1683)\n  at dev.larf.languages.slop.src.operations.NumericOperation.process(NumericOperation.java:63)\n  at dev.larf.operations.TypeOperation.processOperation(TypeOperation.java:49)\n  at dev.larf.parser.LARFParser.processOp(LARFParser.java:443)\n  at dev.larf.parser.LARFParser.processExpression(LARFParser.java:151)\n  at dev.larf.languages.slop.src.tokens.statements.SingleLineToken.process(SingleLineToken.java:54)\n  at dev.larf.tokens.Token.processNoParams(Token.java:249)\n")),(0,a.yg)("p",null,"You can see we have two stack traces with one for our code and the second for the JVM. If you want to only show the\nin-language trace then we can simply disable this by setting ",(0,a.yg)("inlineCode",{parentName:"p"},"showNative = false")," in the constructor of our\nerror handler:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class SLOPStandardErrorHandler extends StandardErrorHandler {\n\n    public SLOPStandardErrorHandler(String name) {\n        super(name);\n        showNative = false;\n    }\n    \n    //...\n}\n")),(0,a.yg)("p",null,"Using this approach can save a lot of time as opposed to having to define your own each each scenario. The name\nmappings e.g. ",(0,a.yg)("inlineCode",{parentName:"p"},"AritheticError")," above can be used to throw your own errors of these types within your language.\nThese errors by default are unchecked and will not need to be caught."),(0,a.yg)("h3",{id:"custom-errors"},"Custom Errors"),(0,a.yg)("p",null,"First we need to define the names for each type of error we want to represent in our language. We do this by\ncreating a class which extends the ",(0,a.yg)("inlineCode",{parentName:"p"},"NativeErrorHandler"),". This only has one method which it is required to\noverwrite which is the ",(0,a.yg)("inlineCode",{parentName:"p"},"initErrorHandlers")," as can be seen below:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'public class SLOPNativeErrorHandler extends NativeErrorHandler {\n\n    public SLOPNativeErrorHandler(String name) {\n        super(name);\n    }\n\n    @Override\n    public void initErrorHandlers() {\n        addErrorMapping("Error", NativeError.CHECKED);\n        addErrorMapping("RunError", NativeError.UNCHECKED);\n    }\n}\n')),(0,a.yg)("p",null,"In the case above we're assigning ",(0,a.yg)("inlineCode",{parentName:"p"},"Error")," to checked errors and `",(0,a.yg)("inlineCode",{parentName:"p"},"RunError")," to unchecked errors. We can now\nadd this along with our standard error handler in our configuration:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"@Override\nprotected void initErrorHandlers() {\n    addErrorHandler(new SLOPStandardErrorHandler(null));\n    addErrorHandler(new SLOPNativeErrorHandler(null));\n}\n")),(0,a.yg)("p",null,"SLOP follows the typical form of error handling where errors / exceptions can be thrown. As such, let's perform\nthe next step logical step and define a token to handle these:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class ThrowsToken extends ErrorToken {\n\n    public ThrowsToken() {\n        super(\"throws\", ErrorAction.THROWS);\n    }\n\n    @Override\n    public Token<Void> createToken(String value) { \n        return cloneDefaultProperties(new ThrowsToken());\n    }\n\n    @Override\n    public PatternType getPatternType() { return PatternType.GRAMMAR; }\n\n    @Override\n    public String getPattern() { return \"'throws' ( error ','? )+\"; }\n\n    @Override\n    public Optional<String> getGuidance(String token, List<Integer> groupsCount) { \n        return Optional.empty(); \n    }\n\n    @Override\n    protected List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) { \n        return null; \n    }\n\n    @Override\n    public List<ErrorHandler<?>> getErrorHandlers() { return null; }\n\n    @Override\n    public List<String> getErrorTypes() { return getErrorTypes(0); }\n}\n")),(0,a.yg)("p",null,"This extends the class ",(0,a.yg)("inlineCode",{parentName:"p"},"ErrorToken")," which provides functionality to handle error types. It's sole purpose as can\nbe seen from the pattern is to define error types. You'll notice that errors have their own grammar keyword. This is so\nthat when an error in your language is declared, it is assigned to the parent type ",(0,a.yg)("inlineCode",{parentName:"p"},"ErrorHandler<T>")," and can\nbe handled accordingly in grammar and elsewhere for special cases. The ",(0,a.yg)("inlineCode",{parentName:"p"},"getErrorTypes")," method returns these references\nto be used for things like error validation. This is so that if the code contained within the token to which this\n",(0,a.yg)("inlineCode",{parentName:"p"},"throws")," token is associated (typically a Function variant) and a checked exception is being thrown by any children\nbut not declared, an error will be thrown. Following normal operation, all checked exceptions must be declared if one\nis thrown downstream. You'll also see that we've declared the name of our token throws\n(",(0,a.yg)("inlineCode",{parentName:"p"},'super("throws", ErrorAction.THROWS);'),") in the constructor. We'll see that used in a single grammar reference in the\ngrammar of our next token:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class FunctionToken extends Token<Void> implements TokenParameters {\n\n    //...\n\n    @Override\n    public String getPattern() {\n        return \"'func' val '(' ( val ','? )+ ')' ( [ throws ] )? [ singleLine, multiLine ]\";\n    }\n\n    //...\n\n    public List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config, \n                                  List<Token<?>> providedParams) {\n        String functionName = getTokenGroups().get(0).getFlatTokens().get(0).getValue().toString();\n        List<Token<?>> paramVars = getTokenGroups().get(1).getFlatTokens();\n        if (paramVars.size() != providedParams.size()) {\n            throw new ParserException(String.format(\"Function %s expected %d parameters, but only \" +\n                    \"called with %d\", functionName, paramVars.size(), providedParams.size()));\n        }\n        for (int i = 0;i < paramVars.size();i++) {\n            context.set(paramVars.get(i).getValue(String.class), providedParams.get(i), \n                    VariableType.PARAMETER);\n        }\n        Token<?> result = parser.processExpression(getTokenGroups().get(3).getFlatTokens(), context);\n        if (!result.getParserFlags().isEmpty() && !result.getParserFlags()\n                    .contains(ParserFlag.ERROR)) {\n            //Unwrap result as we don't want to return token any further\n            return Collections.singletonList(result.getValue() instanceof Token ?\n                    (Token<?>)result.getValue() : new TokenValue(result.getValue()));\n        }\n        return Collections.singletonList(result);\n    }\n\n    @Override\n    public List<ErrorToken> getThrowsToken() {\n        return getTokenGroups().get(2).getFlatTokens().stream()\n                .filter(t -> t instanceof ErrorToken)\n                .map(ErrorToken.class::cast)\n                .filter(t -> t.getErrorAction() == ErrorAction.THROWS)\n                .collect(Collectors.toList());\n    }\n\n    //...\n}\n")),(0,a.yg)("p",null,"I have covered the implementation of the FunctionToken elsewhere ",(0,a.yg)("a",{parentName:"p",href:"/docs/toolkit/tokens/functions"},"here"),", so instead have just\nleft the methods relevant to error handling. First, you'll notice the reference to our ThrowToken in the grammar e.g.\n",(0,a.yg)("inlineCode",{parentName:"p"},"( [ throws ] )?"),". This declares that the token may appear here, but is not guaranteed. This follows the typical\npattern where you can declare the following:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"func myFunc(a,b,c) throws SimpleError {\n    //...\n}\n")),(0,a.yg)("admonition",{title:"Error Checking Limitation",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"Currently the handling for validating checked errors happens within the main Token class. This is hardcoded using a\nprivate method in the class. Given this is not ideal and goes against open nature of the framework, I am looking to\nmove this into a more dedicated error handling class where you can override this behaviour if you so wish.")),(0,a.yg)("p",null," This will allow our checked exceptions to be validated, but let's define a way to handle these within our functions.\nFor that we'll create the next class which is TryCatchToken:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class TryCatchToken extends ErrorToken {\n\n   public TryCatchToken() {\n       super(\"Try-Catch\", ErrorAction.CATCH);\n   }\n\n   public Token<Void> createToken(String value) {\n       return cloneDefaultProperties(new TryCatchToken());\n   }\n\n   @Override\n   public PatternType getPatternType() {\n       return PatternType.GRAMMAR;\n   }\n\n   @Override\n   public String getPattern() {\n       return \"'try' [ singleLine, multiLine ] 'catch' '(' error ')' [ singleLine, multiLine ]\";\n   }\n\n   @Override\n   public Optional<String> getGuidance(String token, List<Integer> groupsCount) {\n       return Optional.empty();\n   }\n\n   @Override\n   protected List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n       Token<?> result = parser.processExpression(getTokenGroups().get(0).getFlatTokens(), context);\n       if (result.getParserFlags().contains(ParserFlag.ERROR)) {\n           Token<?> variableToken = getTokenGroups().get(1).getFlatTokens().get(0);\n           context.set(variableToken.getValue().toString(), result);\n           return Collections.singletonList(parser.processExpression(\n                   getTokenGroups().get(2).getFlatTokens(), context));\n       }\n       return Collections.singletonList(result);\n   }\n\n   @Override\n   public List<ErrorHandler<?>> getErrorHandlers() {\n       return null;\n   }\n\n   @Override\n   public List<String> getErrorTypes() {\n       return getErrorTypes(1);\n   }\n}\n")),(0,a.yg)("p",null," Let's first look at the pattern:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"'try' [ singleLine, multiLine ] 'catch' '(' error ')' [ singleLine, multiLine ]\n")),(0,a.yg)("p",null," First we start out with the 'try' syntax and then have a branching path for either a single or multi-line\ncode block. We next have a 'catch' word and then a pair of brackets which contain a single ",(0,a.yg)("inlineCode",{parentName:"p"},"error"),". This\ncould be modified to handle multiple errors by changing the pattern to ",(0,a.yg)("inlineCode",{parentName:"p"},"'(' ( error )+ ')' "),". We then\nfinish off with another single or multi-line definition. Let's now look at the ",(0,a.yg)("inlineCode",{parentName:"p"},"process")," method\ndefinition. First we process the content of the first code block and get the result. We then check the\nresult to see if it contains the ERROR parser flag. If it is then we know an error has been thrown."),(0,a.yg)("p",null," We then store the active error to context and then process the error token by the parser. The current\nimplementation uses this ",(0,a.yg)("inlineCode",{parentName:"p"},"activeError")," stored into context"))}u.isMDXComponent=!0},6214:(e,r,n)=>{n.d(r,{A:()=>t});const t=n.p+"assets/images/error-a295ba650e219fafa1bc7dee2623ef87.jpg"}}]);