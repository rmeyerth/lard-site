"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[7562],{5680:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>g});var r=n(6540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),f=o,g=u["".concat(l,".").concat(f)]||u[f]||d[f]||i;return n?r.createElement(g,a(a({ref:t},c),{},{components:n})):r.createElement(g,a({ref:t},c))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:o,a[1]=s;for(var p=2;p<i;p++)a[p]=n[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},6016:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=n(8168),o=(n(6540),n(5680));const i={sidebar_position:1},a="Overview",s={unversionedId:"toolkit/parser/overview",id:"toolkit/parser/overview",title:"Overview",description:"Parser Overview",source:"@site/docs/toolkit/parser/overview.md",sourceDirName:"toolkit/parser",slug:"/toolkit/parser/overview",permalink:"/docs/toolkit/parser/overview",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/toolkit/parser/overview.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Design Overview",permalink:"/docs/toolkit/design-overview"},next:{title:"Formatters",permalink:"/docs/toolkit/parser/formatters"}},l={},p=[],c={toc:p},u="wrapper";function d(e){let{components:t,...i}=e;return(0,o.yg)(u,(0,r.A)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"overview"},"Overview"),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"Parser Overview",src:n(3823).A,width:"1885",height:"420"}),"\nWhere lexers transform code into a series of hierarchical tokens, the parser is responsible for executing those\ntokens and deriving results from them. It acts as a central pillar for all the literals, operators, handlers\nand statements in your language and enable them to work cohesively together. Every token has access to the\nparser via the ",(0,o.yg)("inlineCode",{parentName:"p"},"process")," method. This can be used when you need to evaluate the content of a token group\nfrom your token. "),(0,o.yg)("p",null,"Let's look at an example from a ternary statement token. In this statement you would have 3 ",(0,o.yg)("inlineCode",{parentName:"p"},"expr")," (token groups)\ndefined in your pattern. The first goup represents the condition, whereas the second and third are evaluated if\nthe condition results in true and false respectively. Let's look at how this is defined:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},'public class ConditionalToken extends Token<Void> {\n\n    //...\n\n    @Override\n    public String getPattern() {\n        //condition ? trueResult : falseResult\n        return "expr \'?\' expr \':\' expr";\n    }\n\n    @Override\n    public List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n        //Expect that there are 3 tokens groups representing the condition and true / false token groups\n        if (getTokenGroups().size() < 3) {\n            String found = getTokenGroups().stream().map(Token::toSimpleString)\n                    .collect(Collectors.joining(","));\n            throw new ParserException(String.format("Condition does not have required arguments to " +\n                    "execute. Expecting 3 groups being condition, trueResult and falseResult. " + \n                    "Found: [%s]", found));\n        }\n        //Evaluate the condition using the tokens found in the first token group\n        Token<?> conditionResult = parser.processExpression(getTokenGroups().get(0).getTokens(), context);\n        //If the condition is not a Boolean then throw an error i.e. "1 + 2 ? 3 : 4"\n        if (!(conditionResult instanceof BooleanToken)) {\n            throw new ParserException(String.format("Expected a boolean result from condition \'%s\'. " + \n                            "Possible invalid condition specified", getTokenGroups().get(0)));\n        }\n        //Execute the relevant set of tokens based on the condition result\n        return Collections.singletonList((((BooleanToken) conditionResult).getValue()) ?\n                parser.processExpression(getTokenGroups().get(1).getFlatTokens(), context) :\n                parser.processExpression(getTokenGroups().get(2).getFlatTokens(), context));\n    }\n\n    //...\n}\n')),(0,o.yg)("p",null,"Above we perform some basic validation to verify that 3 token groups have been specified. In next line we make a call\nto the parser to evaluate the tokens in group 0 (condition). The current token should only be concerned with its own\nlogic and can defer resolution of tokens / groups to the parser using ",(0,o.yg)("inlineCode",{parentName:"p"},"parser.processExpression(...)"),"."),(0,o.yg)("p",null,"Once a result has been returned, it is verified that it is indeed a Boolean if so proceeds to perform a Java ternary\noperation to make a call to the parser to evaluate the relevant token group."))}d.isMDXComponent=!0},3823:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/parser-56e1c26dbe719e3186e8fde94d588827.jpg"}}]);