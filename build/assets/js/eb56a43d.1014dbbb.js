"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[8453],{5680:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>g});var o=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=o.createContext({}),l=function(e){var t=o.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return o.createElement(p.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},y=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=l(n),y=r,g=d["".concat(p,".").concat(y)]||d[y]||u[y]||a;return n?o.createElement(g,i(i({ref:t},c),{},{components:n})):o.createElement(g,i({ref:t},c))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=y;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}y.displayName="MDXCreateElement"},734:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var o=n(8168),r=(n(6540),n(5680));const a={sidebar_position:9},i="Type Operations",s={unversionedId:"toolkit/type-operations",id:"toolkit/type-operations",title:"Type Operations",description:"Type Operations",source:"@site/docs/toolkit/type-operations.md",sourceDirName:"toolkit",slug:"/toolkit/type-operations",permalink:"/docs/toolkit/type-operations",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/toolkit/type-operations.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Operators",permalink:"/docs/toolkit/operators"},next:{title:"Typed / Typeless",permalink:"/docs/toolkit/typed-typeless"}},p={},l=[],c={toc:l},d="wrapper";function u(e){let{components:t,...a}=e;return(0,r.yg)(d,(0,o.A)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"type-operations"},"Type Operations"),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"Type Operations",src:n(2588).A,width:"1468",height:"298"}),"\nWhilst operators are used as an identifier to allow the developer to perform operations on two operands, a\ntype operation is the class which defines the action that operator has and the types that are supported. Let's\nlook at an example of a simple type operation class:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'public class BooleanOperation extends TypeOperation {\n\n    public BooleanOperation() {\n        super("BooleanOp");\n    }\n\n    /**\n     * See {@link TypeOperation#canHandle(Token, OperatorHandler, Token) canHandle}\n     */\n    @Override\n    public boolean canHandle(Token<?> first, OperatorHandler<?> operator, Token<?> second) {\n        return first.is(Boolean.class) && second.is(Boolean.class);\n    }\n\n    /**\n     * See {@link TypeOperation#process(LARFConfig, LARFContext, Token, OperatorHandler, Token, \n     * UnhandledEvent) process}\n     */\n    @Override\n    public Token<?> process(LARFConfig config, LARFContext context, Token<?> first, \n                            OperatorHandler<?> operator, Token<?> second, \n                            UnhandledEvent unhandledEvent) {\n        boolean result = false;\n        if (operator instanceof ComparisonOperator) {\n            switch (((ComparisonOperator)operator).getOpType()) {\n                case EQUAL: result = first.getValue(Boolean.class).equals(\n                                     second.getValue(Boolean.class)); \n                            break;\n                case NOT_EQUAL: result = !first.getValue(Boolean.class).equals(\n                                         second.getValue(Boolean.class)); \n                            break;\n                default: return unhandledEvent.trigger();\n            }\n        } else if (operator instanceof AssignmentOperator) {\n            switch (((AssignmentOperator)operator).getOpType()) {\n                case ASSIGN: return first.set(context, second);\n                default: return unhandledEvent.trigger();\n            }\n        }\n        return new BooleanToken(result);\n    }\n}\n')),(0,r.yg)("p",null,"This class represents all the operations that can happen with booleans. Breaking this down we can see that there\nare two required methods which are ",(0,r.yg)("inlineCode",{parentName:"p"},"canHandle")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"process"),". The former determines the type compatibility\nwe want to enforce against the two operands. In this case both have to be of type Boolean, but in other scenarios you\nmay want to be more flexible. Let's take a closer look at the definition of the ",(0,r.yg)("inlineCode",{parentName:"p"},"process")," method. It has six\nparameters which are the following:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"The configuration object"),(0,r.yg)("li",{parentName:"ol"},"The context object"),(0,r.yg)("li",{parentName:"ol"},"The first operand e.g. ",(0,r.yg)("strong",{parentName:"li"},"<","operand",">")," ","<","operator",">"," ","<","operand",">"," (",(0,r.yg)("strong",{parentName:"li"},"1")," + 2)"),(0,r.yg)("li",{parentName:"ol"},"The operator e.g. ","<","operand",">"," ",(0,r.yg)("strong",{parentName:"li"},"<","operator",">")," ","<","operand",">"," (1 ",(0,r.yg)("strong",{parentName:"li"},"+")," 2)"),(0,r.yg)("li",{parentName:"ol"},"The second operand e.g. ","<","operand",">"," ","<","operator",">"," ",(0,r.yg)("strong",{parentName:"li"},"<","operand",">")," (1 + ",(0,r.yg)("strong",{parentName:"li"},"2"),")"),(0,r.yg)("li",{parentName:"ol"},"A lambda method which is run when the operator / operand combination is not handled")),(0,r.yg)("p",null,"Next we'll take a look at what the ",(0,r.yg)("inlineCode",{parentName:"p"},"process")," method is doing in this situation. It is checking the type of the\noperator against each of our defined operator types. There are several sets defined (for more information on this\nand you can even create your own. For more information on this please see the ",(0,r.yg)("a",{parentName:"p",href:"/docs/toolkit/operators"},"Operators"),") section.\nLet's take a closer look at one section:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"if (operator instanceof ComparisonOperator) {\n    switch (((ComparisonOperator)operator).getOpType()) {\n        case EQUAL: result = first.getValue(Boolean.class).equals(\n                             second.getValue(Boolean.class)); \n                    break;\n        case NOT_EQUAL: result = !first.getValue(Boolean.class).equals(\n                                 second.getValue(Boolean.class)); \n                    break;\n        default: return unhandledEvent.trigger();\n    }\n}\n")),(0,r.yg)("p",null,"Here we are checking that the operator matches the type comparison. If it is then we compare the operators OpType\nagainst the enum value defined for each set of operators e.g. Arithmetic, Bitwise, Comparison etc. In each case\nwe'll perform the operation and set the result to a value. If no cases are matched then the default always calls\nthe standard ",(0,r.yg)("inlineCode",{parentName:"p"},"unhandledEvent.trigger()")," method. For the cases, we could return the result directly in a BooleanToken,\nbut taking this approach is useful should we want to do logging or debugging."),(0,r.yg)("p",null,"To handle different sets of operators, it's simply a case of checking the operator against each set for a match. To\nregister this class, simply add it to the ",(0,r.yg)("inlineCode",{parentName:"p"},"initTypeOperations")," methods in your configuration class implementation:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"    @Override\n    protected TypeOperation initTypeOperations() {\n        addTypeOperation(new DateOperation());\n        addTypeOperation(new EnumOperation());\n        addTypeOperation(new StringOperation());\n        addTypeOperation(new NumericOperation());\n        addTypeOperation(new BooleanOperation());\n        addTypeOperation(new ArrayOperation());\n        addTypeOperation(new MapOperation());\n        addTypeOperation(new NullOperation());\n        //Fallback\n        return new ObjectOperation();\n    }\n")))}u.isMDXComponent=!0},2588:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/operations-b4dd89cf55ef8d9870839395ab90c50b.jpg"}}]);