"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[3179],{5680:(e,t,r)=>{r.d(t,{xA:()=>c,yg:()=>m});var n=r(6540);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var p=n.createContext({}),l=function(e){var t=n.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=l(r),g=a,m=u["".concat(p,".").concat(g)]||u[g]||d[g]||o;return r?n.createElement(m,i(i({ref:t},c),{},{components:r})):n.createElement(m,i({ref:t},c))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=g;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}g.displayName="MDXCreateElement"},5954:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var n=r(8168),a=(r(6540),r(5680));const o={sidebar_position:8},i="Operators",s={unversionedId:"toolkit/operators",id:"toolkit/operators",title:"Operators",description:"Operators",source:"@site/docs/toolkit/operators.md",sourceDirName:"toolkit",slug:"/toolkit/operators",permalink:"/docs/toolkit/operators",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/toolkit/operators.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"System Functions",permalink:"/docs/toolkit/system-functions"},next:{title:"Type Operations",permalink:"/docs/toolkit/type-operations"}},p={},l=[{value:"Custom Operators",id:"custom-operators",level:3}],c={toc:l},u="wrapper";function d(e){let{components:t,...o}=e;return(0,a.yg)(u,(0,n.A)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"operators"},"Operators"),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"Operators",src:r(5867).A,width:"1465",height:"301"}),"\nOperators can be broken down into 5 distinct types:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Arithmetic (Add, Subtract, Multiply, Divide, Modulo etc)"),(0,a.yg)("li",{parentName:"ol"},"Assignment (Assign, Subtract Equals, Add Equals, Multiply Equals etc)"),(0,a.yg)("li",{parentName:"ol"},"Bitwise - (AND, OR, XOR, NOT, Left Shift, Right Shift)"),(0,a.yg)("li",{parentName:"ol"},"Comparison - (Greater Than, Less Than, Equal, Not Equal etc)"),(0,a.yg)("li",{parentName:"ol"},"Logical - (And, Or)")),(0,a.yg)("p",null,"To add these to your language there is an equivalent template class for each type defined within LARF. Using Arithmetic\noperators as an example, if we wanted to define our operator set we would create a new class e.g. MyArithmeticOperators\nand extend that class by ArithmeticOperator. This would require us to define several methods:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'public class SLOPArithmeticOperator extends ArithmeticOperator {\n\n    public SLOPArithmeticOperator(String value) {\n        super(value);\n    }\n\n    @Override\n    public Token<String> createToken(String value) {\n        return new SLOPArithmeticOperator(value);\n    }\n\n    @Override\n    public String getPattern() {\n        return "^(\\\\+\\\\+|--|\\\\+|-|\\\\*|\\\\/|%)";\n    }\n\n    @Override\n    protected void initOperators() {\n        addOperator("+", ArithmeticOperatorType.ADD);\n        addOperator("-", ArithmeticOperatorType.SUBTRACT);\n        addOperator("*", ArithmeticOperatorType.MULTIPLY);\n        addOperator("/", ArithmeticOperatorType.DIVIDE);\n        addOperator("%", ArithmeticOperatorType.MODULO);\n        addOperator("++", ArithmeticOperatorType.INCREMENT);\n        addOperator("--", ArithmeticOperatorType.INCREMENT);\n    }\n\n    @Override\n    public String[][] getOperatorOrder() {\n        return new String[][] {\n                {"++", "--"},\n                {"*", "/", "%"},\n                {"+", "-"}\n        };\n    }\n}\n')),(0,a.yg)("p",null,"This class is used to match and store each operator as it is found in code. The pattern is a regular expression used to\nmake the initial match and is then stored as a value via the createToken method / constructor. This class also defines\nthe supported operator types as well as what their String equivalent should be. These are defined in the ",(0,a.yg)("inlineCode",{parentName:"p"},"initOperators"),"\nmethod using the ",(0,a.yg)("inlineCode",{parentName:"p"},"addOperator(..)")," method. For an arithmetic operator, we define each type by using the\nArithmeticOperatorType enum."),(0,a.yg)("admonition",{title:"Ensure correct regex order",type:"danger"},(0,a.yg)("p",{parentName:"admonition"},"Please ensure that you've declared your regular expression pattern correctly. Otherwise this could lead to an operator\nnever being matched if another one matches less characters that precedes it. For example, placing ",(0,a.yg)("inlineCode",{parentName:"p"},"+")," before ",(0,a.yg)("inlineCode",{parentName:"p"},"++"),"\nwould cause this scenario. This is because an increment would be matched as two add operators. As such, when defining\nyour pattern, ensure you place the longer match before the shorter one e.g. ",(0,a.yg)("inlineCode",{parentName:"p"},"^(\\\\+\\\\+|\\\\+)"))),(0,a.yg)("p",null,"Operator classes for the most part use a similar naming style, but for completeness please the full table is below:"),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Operator Type"),(0,a.yg)("th",{parentName:"tr",align:null},"Template Class"),(0,a.yg)("th",{parentName:"tr",align:null},"Type Enum"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Arithmetic"),(0,a.yg)("td",{parentName:"tr",align:null},"ArithmeticOperator"),(0,a.yg)("td",{parentName:"tr",align:null},"ArithmeticOperatorType")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Assignment"),(0,a.yg)("td",{parentName:"tr",align:null},"AssignmentOperator"),(0,a.yg)("td",{parentName:"tr",align:null},"AssignmentOperatorType")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Bitwise"),(0,a.yg)("td",{parentName:"tr",align:null},"BitwiseOperator"),(0,a.yg)("td",{parentName:"tr",align:null},"BitwiseOperatorType")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Comparison"),(0,a.yg)("td",{parentName:"tr",align:null},"ComparisonOperator"),(0,a.yg)("td",{parentName:"tr",align:null},"ComparisonOperatorType")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Logical"),(0,a.yg)("td",{parentName:"tr",align:null},"LogicOperator"),(0,a.yg)("td",{parentName:"tr",align:null},"LogicalOperatorType")))),(0,a.yg)("h3",{id:"custom-operators"},"Custom Operators"),(0,a.yg)("p",null,"You are not restricted to using those common operators. If you'd like to define them all yourself or just a single set,\nyou can follow the following steps:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Create a new enum class that represents your custom operators"),(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public enum MyCustomOperators {\n    SQUARE,\n    SQUARE_ROOT\n}\n"))),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Define a concrete class for your Operators e.g. CustomOperators and extend the OperatorHandler class while passing\nin your enum as a generic type."),(0,a.yg)("admonition",{parentName:"li",title:"Ensure correct regex order",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"You'll also need to pass the class of your operator enum type in the constructor for these custom operator classes.\nThis is not necessary when using the standard operator templates.")),(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre",className:"language-java"},'public class CustomOperators extends OperatorHandler<MyCustomOperators> {\n\n    protected CustomOperators(String value) {\n        super(MyCustomOperators.class, "Custom Operator", value);\n    }\n\n    @Override\n    public PatternType getPatternType() {\n        return PatternType.REGEX;\n    }\n\n    @Override\n    public Optional<String> getGuidance(String token, List<Integer> groupsCount) {\n        return Optional.empty();\n    }\n\n    @Override\n    public List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n        return Collections.singletonList(this);\n    }\n\n    @Override\n    public String getPattern() {\n        return "^(\\\\^|_/)";\n    }\n\n    @Override\n    protected void initOperators() {\n        // 4 ^ 2 = 16\n        addOperator("^", MyCustomOperators.SQUARE);\n        // _/16 = 4\n        addOperator("_/", MyCustomOperators.SQUARE_ROOT, \n              Collections.singletonList(Operands.RIGHT_HAND_SIDE));\n    }\n\n    @Override\n    public String[][] getOperatorOrder() {\n        return new String[][] {\n             {"^", "_/"}\n        };\n    };\n\n    @Override\n    public int getHandlerOrder() {\n        return 1;\n    }\n}\n')),(0,a.yg)("p",{parentName:"li"},"You'll notice that on the square root operator above, we're passing in another parameter. This is a list of\napplicable operands that can be used with the operator. The default is Operands.BOTH where the operator takes\nboth a left and right side. In this case though the square root only take a right-side operand and cannot be\nused in any other situation.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Modify your operation class and handle both operator types within the ",(0,a.yg)("inlineCode",{parentName:"p"},"process")," method:"),(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre",className:"language-java"},"@Override\npublic Token<?> process(LARFConfig config, LARFContext context, Token<?> firstToken, OperatorHandler<?> operator,\n                        Token<?> secondToken, UnhandledEvent unhandledEvent) {\n    BigDecimal first = Objects.isNull(firstToken.getValue()) ?\n            BigDecimal.ZERO : new BigDecimal(firstToken.getValue().toString());\n    BigDecimal second = Objects.isNull(secondToken.getValue()) ?\n            BigDecimal.ZERO : new BigDecimal(secondToken.getValue().toString());\n    if (operator instanceof ArithmeticOperator) {\n        //... \n    } else if (operator instanceof IndentCustomOperator) {\n        switch (((IndentCustomOperator)operator).getOpType()) {\n           case SQUARE: return convert(first.pow(second.abs().intValue()));\n           case SQUARE_ROOT: return convert(BigDecimal.valueOf(Math.sqrt(second.doubleValue())));\n        }\n    }\n    return unhandledEvent.trigger();\n}\n"))),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Add your custom operator class to the configuration file:"),(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre",className:"language-java"},"@Override\nprotected void initOperators() {\n    //...\n    addOperatorHandler(new IndentCustomOperator(null));\n}\n"))),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Give it a try:"),(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre"},"Indent Language Test Utility\n============================\n4 ^ 2\nResult: 16 (Type: Integer, Time taken: 26ms)\n_/16\nResult: 4 (Type: Integer, Time taken: 3ms)\n")))))}d.isMDXComponent=!0},5867:(e,t,r)=>{r.d(t,{A:()=>n});const n=r.p+"assets/images/operators-92cd57650ec250ae5dd4a46df592eaaf.jpg"}}]);