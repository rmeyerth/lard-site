"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[370],{5680:(e,t,n)=>{n.d(t,{xA:()=>f,yg:()=>g});var r=n(6540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},f=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,f=s(e,["components","mdxType","originalType","parentName"]),c=l(n),u=o,g=c["".concat(p,".").concat(u)]||c[u]||d[u]||i;return n?r.createElement(g,a(a({ref:t},f),{},{components:n})):r.createElement(g,a({ref:t},f))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[c]="string"==typeof e?e:o,a[1]=s;for(var l=2;l<i;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8404:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=n(8168),o=(n(6540),n(5680));const i={sidebar_position:4},a="Prefix, Infix and Postfix",s={unversionedId:"toolkit/parser/prefix-infix-postfix",id:"toolkit/parser/prefix-infix-postfix",title:"Prefix, Infix and Postfix",description:"Ordering",source:"@site/docs/toolkit/parser/prefix-infix-postfix.md",sourceDirName:"toolkit/parser",slug:"/toolkit/parser/prefix-infix-postfix",permalink:"/docs/toolkit/parser/prefix-infix-postfix",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/toolkit/parser/prefix-infix-postfix.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Parser Flags",permalink:"/docs/toolkit/parser/parser-flags"},next:{title:"Processor",permalink:"/docs/toolkit/processor"}},p={},l=[{value:"Infix Notation",id:"infix-notation",level:3},{value:"Prefix Notation",id:"prefix-notation",level:3},{value:"Postfix Notation",id:"postfix-notation",level:3}],f={toc:l},c="wrapper";function d(e){let{components:t,...i}=e;return(0,o.yg)(c,(0,r.A)({},f,i,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"prefix-infix-and-postfix"},"Prefix, Infix and Postfix"),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"Ordering",src:n(8728).A,width:"1258",height:"319"}),"\nThe majority of programming languages follow the standard left-to-right (Infix) execution of values\nand operators. LARF however offers support for alternatives including Prefix and Postfix which are\nmore commonly used in mathematical notation. To change the expression notation type, a method on the\nconfiguration class called ",(0,o.yg)("inlineCode",{parentName:"p"},"config.setNotationType()")," can be used which accepts a ExpressionNotationType\nargument. An example of running a language with prefix notation would be:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},'public class PrefixRunner extends LARFRunner {\n    public static void main(String[] args) {\n        PrefixConfig config = new PrefixConfig();\n        //ExpressionNotationType: INFIX [Default], PREFIX, POSTFIX\n        config.setNotationType(ExpressionNotationType.PREFIX);\n        LARFProcessor processor = new LARFProcessor(config);\n        run("My Prefix Language", processor);\n    }\n}\n')),(0,o.yg)("h3",{id:"infix-notation"},"Infix Notation"),(0,o.yg)("p",null,"This is enabled by default and follows the typical pattern where an operator is placed between two\nvalues. For example, ",(0,o.yg)("inlineCode",{parentName:"p"},"1 + 2")," moves from left to right by first taking the 1, then adding the\nresult to the value on the right-side. This can differ dependent on the operator order defined in\nthe operator handler classes (see ",(0,o.yg)("a",{parentName:"p",href:"/docs/toolkit/operators"},"getOperatorOrder"),"). For example,\ngiven the default BODMAS operator order, with the following ",(0,o.yg)("inlineCode",{parentName:"p"},"1 + 2 * 3")," the multiplication calculation\nwill be performed before the addition. There is a way to influence the order of this using braces e.g.\n",(0,o.yg)("inlineCode",{parentName:"p"},"(1 + 2) * 3")," which would evaluate the contents of the brackets during the execution operation (see\n",(0,o.yg)("a",{parentName:"p",href:"/docs/tutorial/make-a-statement"},"Making a Statement"),")."),(0,o.yg)("h3",{id:"prefix-notation"},"Prefix Notation"),(0,o.yg)("p",null,"Prefix notation works by placing the operators before each pair of values. For example, using the\nabove example of adding 1 and 2, this would be ",(0,o.yg)("inlineCode",{parentName:"p"},"+ 1 2"),". Operator order is not needed for Prefix\nand Postfix notation because the order in which the operations are defined tell the parser how\nto execute it. Using the above example of addition and multiplication, this would now become\n",(0,o.yg)("inlineCode",{parentName:"p"},"+ 1 * 2 3"),". Going from right to left, we can see our first pair of numbers are 2 and 3. We then\nread our first operator which is multiply which gives 6. We then come across another number (1) and\nthe final operator (1 add 6) to give 7."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"Prefix Language Test Utility\n============================\n+ 1 * 2 3\nResult: 7 (Type: Integer, Time taken: 5ms)\n")),(0,o.yg)("h3",{id:"postfix-notation"},"Postfix Notation"),(0,o.yg)("p",null,"Postfix notation scans for an operator from left-to-right. If we take the example ",(0,o.yg)("inlineCode",{parentName:"p"},"1 2 +"),", we scan\nuntil we find the ",(0,o.yg)("inlineCode",{parentName:"p"},"+")," then take the two operands to the left to execute. If we expand that to include\na multiplication where 2 is multiplied by 3, this would become ",(0,o.yg)("inlineCode",{parentName:"p"},"1 2 3 * +"),". Like Prefix, operator order\nis defined by the layout, so scanning from left-to-right again, the first operation we come to is ",(0,o.yg)("inlineCode",{parentName:"p"},"2 3 *"),".\nOnce we evaluate that and get the result 6, we then move to the next operator which is ",(0,o.yg)("inlineCode",{parentName:"p"},"+")," and now have\n",(0,o.yg)("inlineCode",{parentName:"p"},"1 6 +")," which results in 7."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"Postfix Language Test Utility\n============================\n1 2 3 * +\nResult: 7 (Type: Integer, Time taken: 5ms)\n")))}d.isMDXComponent=!0},8728:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/order-90b18063656add3acd964111538f1504.jpg"}}]);