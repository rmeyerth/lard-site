"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[6337],{5680:(e,t,r)=>{r.d(t,{xA:()=>p,yg:()=>y});var n=r(6540);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(r),d=o,y=u["".concat(l,".").concat(d)]||u[d]||m[d]||a;return r?n.createElement(y,i(i({ref:t},p),{},{components:r})):n.createElement(y,i({ref:t},p))}));function y(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},1260:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var n=r(8168),o=(r(6540),r(5680));const a={sidebar_position:2},i="Formatters",s={unversionedId:"toolkit/parser/formatters",id:"toolkit/parser/formatters",title:"Formatters",description:"Formatters",source:"@site/docs/toolkit/parser/formatters.md",sourceDirName:"toolkit/parser",slug:"/toolkit/parser/formatters",permalink:"/docs/toolkit/parser/formatters",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/toolkit/parser/formatters.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/docs/toolkit/parser/overview"},next:{title:"Parser Flags",permalink:"/docs/toolkit/parser/parser-flags"}},l={},c=[],p={toc:c},u="wrapper";function m(e){let{components:t,...a}=e;return(0,o.yg)(u,(0,n.A)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"formatters"},"Formatters"),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"Formatters",src:r(3858).A,width:"1843",height:"396"})),(0,o.yg)("admonition",{title:"Time and Place",type:"tip"},(0,o.yg)("p",{parentName:"admonition"},"You only need to start writing formatters once you start dealing with arrays, maps and custom structures that you'd\nwant to return from your language. They are easy to write but only come later once you've laid the basic types\nand statements.")),(0,o.yg)("p",null,"Formatters allow the evaluated result to be converted into a native language variant. This is because all values within\nthe parser are processed in Token form. In order to convert them so that the are treated as simple Java primitives,\ncollections or objects, you need to unwrap these back to their native forms. For an example, if you're dealing\nwith arrays or collections of values within your own language and want to return that result, you'll need to write\na formatter which converts it from it's token structure. This is easier than you may think so let's a look at an example:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},"/**\n * Recursively scans all elements in the collection and converts the Token types into Java \n * native types.\n */\npublic class CollectionFormatter extends Formatter<Collection<?>> {\n\n    @Override\n    public boolean isMatch(Object object) {\n        return object instanceof Collection;\n    }\n\n    @Override\n    public Optional<Collection<?>> format(Object object) {\n        Collection<?> collection = ((Collection<?>)object);\n        if (collection.stream().allMatch(v -> v instanceof Token<?>)) {\n            return Optional.of(collection.stream()\n                    .map(v -> ((Token<?>)v))\n                    .map(this::recursiveUnwrap)\n                    .collect(Collectors.toList()));\n        }\n        return Optional.empty();\n    }\n}\n")),(0,o.yg)("p",null,"This class extends the base Formatter class and passes a generic type identifying the type that it is to handle. There is\na required ",(0,o.yg)("inlineCode",{parentName:"p"},"isMatch")," method which compares the result object against the formatters type to determine whether it is a\nmatch. The ",(0,o.yg)("inlineCode",{parentName:"p"},"format")," method takes the object and maps it to the correct class so it can be handled. It then loops through\nall items in the collection which are of type Token<?> and unwraps them using the in-built ",(0,o.yg)("inlineCode",{parentName:"p"},"recursiveUnwrap")," method. The\ncollection is then returned via the processor with just the raw values."),(0,o.yg)("p",null,"Depending on what is returned from your language, you'll likely need to write one of these to convert the result. To do this\nyou can create your own formatter by extending the ",(0,o.yg)("inlineCode",{parentName:"p"},"Formatter<T>")," class in the same way above. To configure LARF to use your\nformatter, you simply add the following into your config class:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},"    @Override\n    protected void initParserFormatters() {\n        addParserFormatter(new CollectionFormatter());\n    }\n")),(0,o.yg)("p",null,"This new formatter will then be picked up and convert the results automatically. Here is another example of a formatter\nwhich converts a Map<K,V> structure:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},"/**\n * Recursively scans all elements in the map and converts both the Key / Value's from \n * their Token types into Java native types.\n */\npublic class MapFormatter extends Formatter<Map<?,?>> {\n    @Override\n    public boolean isMatch(Object object) {\n        return object instanceof Map;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Optional<Map<?, ?>> format(Object object) {\n        Map<?,?> collection = ((Map<?,?>)object);\n        if (collection.entrySet().stream()\n                .allMatch(e -> e.getKey() instanceof Token<?> && e.getValue() instanceof Token<?>)) {\n            //Suppress warnings as it doesn't recognise the check we've made\n            Map<Token<?>, Token<?>> tokenMap = (Map<Token<?>, Token<?>>)collection;\n            return Optional.of(tokenMap.entrySet().stream()\n                    .collect(Collectors.toMap(e -> e.getKey().getValue(), \n                        e -> e.getValue().getValue())));\n        }\n        return Optional.empty();\n    }\n}\n")))}m.isMDXComponent=!0},3858:(e,t,r)=>{r.d(t,{A:()=>n});const n=r.p+"assets/images/formatter-52cc063078ee95c6f0bf793f2b922a2d.jpg"}}]);