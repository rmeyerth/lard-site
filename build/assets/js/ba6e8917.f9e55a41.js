"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[354],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>d});var o=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},g="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),g=c(n),h=r,d=g["".concat(l,".").concat(h)]||g[h]||u[h]||a;return n?o.createElement(d,i(i({ref:t},p),{},{components:n})):o.createElement(d,i({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[g]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2454:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=n(8168),r=(n(6540),n(5680));const a={sidebar_position:3},i="Parser Flags",s={unversionedId:"toolkit/parser/parser-flags",id:"toolkit/parser/parser-flags",title:"Parser Flags",description:"Parser Flags",source:"@site/docs/toolkit/parser/parser-flags.md",sourceDirName:"toolkit/parser",slug:"/toolkit/parser/parser-flags",permalink:"/docs/toolkit/parser/parser-flags",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/toolkit/parser/parser-flags.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Formatters",permalink:"/docs/toolkit/parser/formatters"},next:{title:"Prefix, Infix and Postfix",permalink:"/docs/toolkit/parser/prefix-infix-postfix"}},l={},c=[{value:"Loop-based flags",id:"loop-based-flags",level:3},{value:"Special Flags",id:"special-flags",level:3}],p={toc:c},g="wrapper";function u(e){let{components:t,...a}=e;return(0,r.yg)(g,(0,o.A)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"parser-flags"},"Parser Flags"),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"Parser Flags",src:n(7674).A,width:"1891",height:"364"}),"\nRegardless of which programming language you would have used, to mimic certain types of behaviour such as\nreturning a value or using continue or break in a loop, to achieve this in LARF you'll need to use parser flags.\nThis is because the parser needs to change the way it processes tokens in order to support this. For example,\nin the case of a return statement the parser meeds to stop what it's doing and avoid processing any further\ntokens. This may also involve moving many steps back up the call stack in order to reach the level where it\ncan be handled. In this section we'll take a look at some parser flags and how they're used."),(0,r.yg)("h3",{id:"loop-based-flags"},"Loop-based flags"),(0,r.yg)("admonition",{title:"Familiarity",type:"tip"},(0,r.yg)("p",{parentName:"admonition"},"I would suggest familiarising yourself with writing loops before looking at this section. There is an example\nof one loop implementation that can be found ",(0,r.yg)("a",{parentName:"p",href:"/docs/toolkit/tokens/callbacks"},"here"),".")),(0,r.yg)("p",null,"With most loops there is some basic functionality that every language is expected to have. This includes the\nability to break out of the loop and also the ability to skip to the next iteration using defined keywords.\nFor most languages these would be ",(0,r.yg)("inlineCode",{parentName:"p"},"break")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"continue")," respectively. Although the implementation of these\ntokens may at first appear trivial, there is some behaviour required beyond the bounds of the token class itself.\nFor example, if you had the following loop implementation:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},'ageCount = 0;\nfor (employee : company) {\n    if (employee.getName().startsWith("S"))\n        continue;\n    ageCount += employee.getAge();\n}\n')),(0,r.yg)("p",null,"You would not want to continue executing the ",(0,r.yg)("inlineCode",{parentName:"p"},"ageCount += ...")," line if the continue condition is triggered.\nThis is where we need to let the parser know that this is to be handled as a special case. In this case it would\nbe to skip any remaining tokens being processed and move directly to the next iteration. Let's see how these\nparser flags can be utilised by looking at the VariableLoopToken:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'public class VariableLoopToken extends Token<Void> implements TokenCallback {\n    //...\n\n    @Override\n    public List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config, \n                                  ReferenceCallback callback) {\n        List<Token<?>> arrayResult = new ArrayList<>();\n        if (getTokenGroups().size() < 2) {\n            throw new ParserException("Expected a variable and a collection provided in the for each " + \n                    "iterator statement");\n        }\n        Token<?> varArg = getTokenGroups().get(0).getFlatTokens().get(0);\n        //Resolve the variable name to be used to store the iterated object in context\n        String variableName = (varArg instanceof TokenGroup) ?\n                ((TokenGroup)varArg).getFlatTokens().get(0).getValue(String.class) :\n                varArg.getValue(String.class);\n        List<Token<?>> collectionArgs = getTokenGroups().get(1).getFlatTokens();\n        Collection<?> collection;\n        //Resolve the collection object\n        if (collectionArgs.size() == 1 && collectionArgs.get(0) instanceof TokenValue) {\n            String collectionRef = collectionArgs.get(0).getValue(String.class);\n            Object suspectedCollection = context.getContextObject(collectionRef);\n            if (!(suspectedCollection instanceof Collection)) {\n                throw new ParserException(String.format("The reference used in the for each loop (%s) " + \n                        "did not result in a collection. Instead found \'%s\'", collectionRef, \n                        suspectedCollection.getClass().getSimpleName()));\n            }\n            collection = (Collection<?>)suspectedCollection;\n        } else {\n            collection = parser.processExpression(collectionArgs, context).getValue(Collection.class);\n        }\n        for (Object current : collection) {\n            //Set the current object to the defined variable\n            context.set(variableName, current);\n            Optional<Token<?>> result = callback.call();\n            if (result.isPresent()) {\n                if (result.get().getParserFlags().contains(ParserFlag.RETURN_GROUP)) {\n                    arrayResult.add((Token<?>) result.get().getValue());\n                } else if (result.get().getParserFlags().contains(ParserFlag.RETURN)) {\n                    return Collections.singletonList((Token<?>) result.get().getValue());\n                } else if (result.get().getParserFlags().contains(ParserFlag.BREAK)) {\n                    return Collections.singletonList(config.getNullToken());\n                } else if (result.get().getParserFlags().contains(ParserFlag.CONTINUE)) {\n                    //Ignore as we skip to next iteration anyway\n                }\n            }\n        }\n        return Collections.singletonList(new ArrayToken(arrayResult));\n    }\n\n    //...\n}\n')),(0,r.yg)("p",null,"The crucial part here is when we perform a call to the callback implementation in our main ForLoopToken. Let's\ntake a look at that now to see how this is implemented:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'public class ForToken extends Token<Void> {\n    //...\n\n    @Override\n    public List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n        if (getTokenGroups().size() != 2) {\n            String foundTokens = getTokenGroups().stream()\n                    .flatMap(tg -> tg.getFlatTokens().stream())\n                    .map(t -> t.getClass().getSimpleName())\n                    .collect(Collectors.joining(", "));\n            throw new ParserException("For token expects two tokens being the looping portion and the body. Instead got "\n                    + foundTokens);\n        }\n        Token<?> loopToken = getTokenGroups().get(0).getFlatTokens().get(0);\n        Token<?> bodyToken = getTokenGroups().get(1).getFlatTokens().get(0);\n        return loopToken.processWithCallback(parser, context, config, () -> {\n            List<Token<?>> result = bodyToken.processNoParams(parser, context, config);\n            if (result.size() == 1 &&\n                    result.get(0) instanceof ReturnToken ||\n                    result.get(0) instanceof BreakToken ||\n                    result.get(0) instanceof ContinueToken) {\n                return Optional.of(result.get(0));\n            }\n            return Optional.empty();\n        });\n    }\n\n    //...    \n}\n')),(0,r.yg)("p",null,"The callback here is the lambda implementation in which the body token (either a SingleLineToken or MultiLineToken) is\nprocessed and a result is returned. Because loop iterations don't typically return a result, the default for this would\nbe to return an ",(0,r.yg)("inlineCode",{parentName:"p"},"Optional.empty()"),", however in the case that either ReturnToken, BreakToken or ContinueToken is\nreturned then we return that back to the implementating loop class. In our case this is our VariableLoopToken.\nGoing back to our VariableLoopToken ",(0,r.yg)("inlineCode",{parentName:"p"},"process")," method implementation, we can see this section:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"Optional<Token<?>> result = callback.call();\nif (result.isPresent()) {\n    if (result.get().getParserFlags().contains(ParserFlag.RETURN_GROUP)) {\n        arrayResult.add((Token<?>) result.get().getValue());\n    } else if (result.get().getParserFlags().contains(ParserFlag.RETURN)) {\n        return Collections.singletonList((Token<?>) result.get().getValue());\n    } else if (result.get().getParserFlags().contains(ParserFlag.BREAK)) {\n        return Collections.singletonList(config.getNullToken());\n    } else if (result.get().getParserFlags().contains(ParserFlag.CONTINUE)) {\n        //Ignore as we skip to next iteration anyway\n    }\n}\n")),(0,r.yg)("p",null,"In this case we are handling several possible different scenarios with different parser flags. The first of these is a\n",(0,r.yg)("inlineCode",{parentName:"p"},"ParserFlag.RETURN_GROUP")," which is not present in most languages. This option allows you to specify a return statement\nwithin the loop with the addition of an ampersand character to return an explicit result from an iteration. If we were\nlooping our employee example from earlier, we could do the following:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"func getNames() {\n    for (employee : company) {\n        return & employee.getName();\n    }\n}\n")),(0,r.yg)("p",null,"This would result in a collection of employee names being returned. As can be seen, the result from the return in each\niteration bis added to a Collection and is returned when the loop has finished. This deviates from the traditional return\nbehaviour which immediately causes the loop to cease and return a single value. If we loop next to the ",(0,r.yg)("inlineCode",{parentName:"p"},"ParserFlag.RETURN"),",\nthis has the behaviour where it immediately returns the result back to the ForLoopToken so that it can be returned.\nThe ",(0,r.yg)("inlineCode",{parentName:"p"},"ParserFlag.BREAK")," returns a null value which puts an immediate stop to the loop iterating, but unlike the return\nprovides no result. Finally the ",(0,r.yg)("inlineCode",{parentName:"p"},"ParserFlag.CONTINUE")," does nothing as it is the last statement within the main loop\nitself. If this wasn't the case then we could use Java's ",(0,r.yg)("inlineCode",{parentName:"p"},"continue")," to perform the same behaviour."),(0,r.yg)("h3",{id:"special-flags"},"Special Flags"),(0,r.yg)("p",null,"There are three other parser flags which impact execution in different ways. This behaviour is implemented directly within\nthe parser itself rather than being a collaborative effort between a token and parser. The first of these is the\n",(0,r.yg)("inlineCode",{parentName:"p"},"ParserFlag.ERROR")," which is reserved for error handling. This is used in the ErrorHandler class within the default\nLARF framework. If you'd like to learn more about error handling within LARF, please see the ",(0,r.yg)("a",{parentName:"p",href:"/docs/toolkit/error-handling"},"Error Handling"),"\nsection for more details. The next flag is the ",(0,r.yg)("inlineCode",{parentName:"p"},"ParserFlag.JUMP")," which is an implementation of an older method of flow\nmanipulation and control. This is generally avoided in most modern languages due to making the programs harder to being harder\nto maintain and more complex. This is typically only implemented in rare cases like when duplicating an older languages\nfeature set, but if you would like your language to use jumps, please see the ",(0,r.yg)("a",{parentName:"p",href:"/docs/toolkit/jumping"},"Jumping")," section."),(0,r.yg)("p",null,"The final parser flag is the ",(0,r.yg)("inlineCode",{parentName:"p"},"ParserFlag.EXIT")," which causes the program to immediately terminate without any further\nprocessing being conducted. No results are returned and this is only used in very rare circumstances."))}u.isMDXComponent=!0},7674:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/flags-93c5acc19b54393d0fd207e40f8997a5.jpg"}}]);