"use strict";(self.webpackChunklarf_site=self.webpackChunklarf_site||[]).push([[4857],{5680:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>g});var r=n(6540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=a,g=u["".concat(s,".").concat(m)]||u[m]||d[m]||o;return n?r.createElement(g,i(i({ref:t},c),{},{components:n})):r.createElement(g,i({ref:t},c))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8185:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=n(8168),a=(n(6540),n(5680));const o={sidebar_position:7},i="Making a statement",l={unversionedId:"tutorial/make-a-statement",id:"tutorial/make-a-statement",title:"Making a statement",description:"If literals are considered the building blocks of a language, statements are considered the machinery and workers",source:"@site/docs/tutorial/make-a-statement.md",sourceDirName:"tutorial",slug:"/tutorial/make-a-statement",permalink:"/docs/tutorial/make-a-statement",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial/make-a-statement.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Point of decimals",permalink:"/docs/tutorial/point-of-decimals"},next:{title:"To be or not to be?",permalink:"/docs/tutorial/to-be-or-not-to-be"}},s={},p=[],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,a.yg)(u,(0,r.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"making-a-statement"},"Making a statement"),(0,a.yg)("admonition",{title:"Statements",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"If literals are considered the building blocks of a language, statements are considered the machinery and workers\nwhich put the whole thing together. Statements are slightly more complicated to define and understand than literals\ndue to their nature. However, once you get to grip with LARF's powerful grammar system you'll be able to create a new\nconditional, loop or iterative statement in mere minutes, not days.")),(0,a.yg)("p",null,"Let's start by creating a new package within tokens called statements. We'll call it ExpressionToken.java as what\ncan be found within the brackets could be referred to as one:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"[src]\n   [main]\n       [java]\n           [com.aardvark]\n               [config]\n                   AardvarkConfig.java\n               [operations]\n                   IntegerOperation.java\n               [tokens]\n                   [operators]\n                       AardvarkArithmeticOperator.java\n                   [literals]\n                       DecimalToken.java\n                       IntegerToken.java\n                       NullToken.java\n                   [statements]\n                       ExpressionToken.java\n               Application.java\n")),(0,a.yg)("p",null,"Open up the class and extend Token using the Void generic type. There are several differences between this and previous\ntokens we've defined:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'public class ExpressionToken extends Token<Void> {\n\n    public ExpressionToken() {\n        super("Expression", null);\n    }\n\n    @Override\n    public Token<Void> createToken(String value) {\n        return cloneDefaultProperties(new ExpressionToken());\n    }\n\n    @Override\n    public PatternType getPatternType() {\n        return PatternType.GRAMMAR;\n    }\n\n    @Override\n    public String getPattern() {\n        return "\'(\' expr \')\'";\n    }\n\n    @Override\n    public Optional<String> getGuidance(String token, List<Integer> groupsCount) {\n        if (token.equalsIgnoreCase(")"))\n            return Optional.of("An operation requires the contained logic to be wrapped in a pair of braces " + \n                    "e.g. ( <logic> )<--");\n        return Optional.empty();\n  }\n\n    @Override\n    protected List<Token<?>> process(LARFParser parser, LARFContext context, LARFConfig config) {\n        return Collections.singletonList(\n            parser.processExpression(getTokenGroups().get(0).getTokens(), context)\n        );\n    }\n}\n')),(0,a.yg)("p",null,"Let's break this down:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"As we're using Void we simply pass null in the parent call from the constructor."),(0,a.yg)("li",{parentName:"ol"},"The definition in the ",(0,a.yg)("inlineCode",{parentName:"li"},"createToken")," method has changed. Now we wrap the new instance within a superclass method\ncalled ",(0,a.yg)("inlineCode",{parentName:"li"},"cloneDefaultProperties"),". This allows the new instance to copy the pattern tokens generated from the grammar\nstring to the new token. These are used by the lexer to keep track of position and assign lexed tokens into the\ntokens groups."),(0,a.yg)("li",{parentName:"ol"},"The pattern type has changed to GRAMMAR along with the actual pattern defined as ",(0,a.yg)("inlineCode",{parentName:"li"},"'(' expr ')'"),". I won't go into\ntoo much detail at this stage, but any value defined within single quotes is part of the syntax. The ",(0,a.yg)("inlineCode",{parentName:"li"},"expr")," informs\nthe lexer that it should expect one or more tokens in the capture group. I will cover grammar further once we expand\nmore into other statements."),(0,a.yg)("li",{parentName:"ol"},"This is the first time we are actually using the ",(0,a.yg)("inlineCode",{parentName:"li"},"getGuidance")," method. In this case there is only one situation\nthat can occur. This is if the closing brace is not used and the statement is left open. As such, we'll provide some\ntext to the developer about where they went wrong. I'll show an example in the runner below."),(0,a.yg)("li",{parentName:"ol"},"Finally, we come to the ",(0,a.yg)("inlineCode",{parentName:"li"},"process")," method which is where the code is actually resolved. In this case it is very\nsimple as we only have one token group to resolve a value from. Each token group can be fetched using the inherited\n",(0,a.yg)("inlineCode",{parentName:"li"},"getTokenGroups()")," method. This might be a bit hard to get your head around at this stage, so I would suggest trying\nout the ",(0,a.yg)("inlineCode",{parentName:"li"},"(5 + 3) / 2")," example, once the token is configured, in the runner. If you debug the first line you'll\nnotice that the token group has three tokens contained within:",(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre"},"IntegerToken(5)\nAardvarkArithmeticOperator(+)\nIntegerToken(3) \n")),"To resolve that calculation, we simply pass that group back to the parser in the call ",(0,a.yg)("inlineCode",{parentName:"li"},"parser.processExpression"),".\nThe responsibility of the current token only goes so far as to resolve its own logic. Everything else is deferred\nto the contained tokens or, in this case, the NumericOperation class we defined earlier. From there we simply return\nit in a collection.")),(0,a.yg)("p",null,"Let's configure our new token in the configuration class:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public class AardvarkConfig extends LARFConfig {\n    //...\n    @Override\n    protected void initTokenHandlers() {\n        //Literals\n        addTokenHandler(new NullToken());\n        addTokenHandler(new IntegerToken());\n        addTokenHandler(new DecimalToken());\n\n        //Statements\n        addTokenHandler(new ExpressionToken());\n    }\n    //...\n}\n")),(0,a.yg)("p",null,"Now, let's run some examples:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"(5 + 3) / 2\nResult: 4 (Type: Integer, Time taken: 20ms)\n5 + 3 / 2\nResult: 6.5 (Type: Double, Time taken: 4ms)\n3 / (1 + (3 * 3)) - 2\nResult: -1.7 (Type: Double, Time taken: 4ms)\n")),(0,a.yg)("p",null,"There are no restrictions on the level of depth statements can be nested."),(0,a.yg)("p",null,"Ok, let's review what we've achieved so far:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Created our project and runner"),(0,a.yg)("li",{parentName:"ol"},"Literals (Null, Integer and Decimal)"),(0,a.yg)("li",{parentName:"ol"},"Arithmetic Operators"),(0,a.yg)("li",{parentName:"ol"},"Numeric Operation Handler"),(0,a.yg)("li",{parentName:"ol"},"Written our first statement")),(0,a.yg)("p",null,"From all of that effort we've got... a glorified calculator. Don't worry! With all the foundations we're laying,\ndevelopment starts to accelerate exponentially. Soon you'll be able to add even complex statement with little effort.\nIt's now time to move on to our next statement which is a mainstay of most modern languages."))}d.isMDXComponent=!0}}]);